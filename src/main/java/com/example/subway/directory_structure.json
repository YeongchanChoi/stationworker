{
    "__files__": {
        "codes.py": null,
        "directory_structure.json": null,
        "SubwayApplication.java": "package com.example.subway;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.scheduling.annotation.EnableScheduling;\n\n@SpringBootApplication\n@EnableScheduling  // 스케줄링 기능\npublic class SubwayApplication {\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(SubwayApplication.class, args);\n\t}\n}\n"
    },
    "config": {
        "__files__": {
            "DatabaseInitializer.java": "package com.example.subway.config;\n\nimport com.example.subway.repository.TrainInfoRepository;\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.stereotype.Component;\nimport jakarta.annotation.PostConstruct;\n\n/**\n * 애플리케이션이 시작될 때 train_info 테이블을 초기화(전량 삭제)하는 예시\n */\n@Slf4j\n@Component\npublic class DatabaseInitializer {\n\n    private final TrainInfoRepository trainInfoRepository;\n\n    public DatabaseInitializer(TrainInfoRepository trainInfoRepository) {\n        this.trainInfoRepository = trainInfoRepository;\n    }\n\n    @PostConstruct\n    public void initDatabase() {\n        // (1) 기존 train_info 내용 모두 삭제\n        trainInfoRepository.deleteAll();\n\n        // (2) 필요한 경우, 초기 데이터 Insert 가능\n        // ex) trainInfoRepository.save(...);\n\n        log.info(\"[INIT] train_info 테이블을 초기화(deleteAll)했습니다.\");\n    }\n}\n"
        }
    },
    "controller": {
        "__files__": {
            "StationController.java": "package com.example.subway.controller;\n\nimport com.example.subway.domain.TrainInfo;\nimport com.example.subway.dto.StationTrainResponse;\nimport com.example.subway.repository.TrainInfoRepository;\nimport com.fasterxml.jackson.core.type.TypeReference;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.PathVariable;\nimport org.springframework.web.bind.annotation.RestController;\n\nimport java.io.IOException;\nimport java.util.*;\n\n@Slf4j\n@RestController\npublic class StationController {\n\n    private final TrainInfoRepository trainInfoRepository;\n    private final ObjectMapper objectMapper = new ObjectMapper();\n\n    public StationController(TrainInfoRepository trainInfoRepository) {\n        this.trainInfoRepository = trainInfoRepository;\n    }\n\n    @GetMapping(\"/api/station/{stationName}\")\n    public List<StationTrainResponse> getTrainsPassingStation(\n            @PathVariable(\"stationName\") String stationName) {\n\n        List<TrainInfo> allTrains = trainInfoRepository.findAll();\n        List<StationTrainResponse> result = new ArrayList<>();\n\n        for (TrainInfo train : allTrains) {\n            // Parse the JSON stations array into a List<String>\n            List<String> path = convertJsonToList(train.getStationsJson());\n            if (path == null) {\n                // Parsing error or empty JSON\n                continue;\n            }\n\n            // 1) Find the index of the requested station\n            int stationIndex = path.indexOf(stationName);\n            if (stationIndex == -1) {\n                // This train does not pass through stationName\n                continue;\n            }\n\n            // 2) Find the index of the train’s current station\n            int currIndex = path.indexOf(train.getCurrentStation());\n            if (currIndex == -1) {\n                // Edge case: currentStation not found in stationsJson\n                continue;\n            }\n\n            // 3) Calculate remaining stations\n            int remainingStations = stationIndex - currIndex;\n            if (remainingStations < 0) {\n                // Already passed the station\n                continue;\n            }\n\n            // 4) Build the response DTO\n            StationTrainResponse dto = new StationTrainResponse(\n                    train.getTrainNo(),\n                    train.getUpDown(),\n                    train.getExpressYn(),\n                    train.getCurrentStation(),\n                    train.getEndStation(),\n                    remainingStations\n            );\n            result.add(dto);\n        }\n\n        // Sort by ascending “remainingStations”\n        result.sort(Comparator.comparingInt(StationTrainResponse::getRemainingStations));\n\n        return result;\n    }\n\n    /**\n     * Helper method to parse a JSON string representing an array of stations\n     * into a List<String> using Jackson.\n     */\n    private List<String> convertJsonToList(String json) {\n        if (json == null || json.isEmpty()) {\n            return null;\n        }\n        try {\n            return objectMapper.readValue(json, new TypeReference<List<String>>() {});\n        } catch (IOException e) {\n            log.error(\"Failed to parse JSON string: {}\", json, e);\n            return null;\n        }\n    }\n}\n"
        }
    },
    "domain": {
        "__files__": {
            "SubwayData.java": "package com.example.subway.domain;\n\nimport jakarta.persistence.*;\nimport lombok.Getter;\nimport lombok.Setter;\n\n@Entity\n@Getter\n@Setter\npublic class SubwayData {\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id; //고유 id\n\n    private String linenum; //몇호선에 존재하는 관계인지\n\n    /*연결관계는 앞>뒤로 연결됨, 앞 > 뒤의 연결관계 방향에 따라 upDown 상행 하행을 저장*/\n    private String frontStationname; //앞 역 이름\n    private String frontOutercode; //앞 역 외부코드\n\n    private String backStationname; //뒷 역 이름\n    private String backOutercode; //뒷 역 외부코드\n\n\n    private String upDown; //상행 하행 저장정보. 상행(내선):0 , 하행(외선):1\n\n}\n",
            "SubwayStations.java": "package com.example.subway.domain;\n\nimport jakarta.persistence.Entity;\nimport jakarta.persistence.Id;\nimport lombok.Getter;\nimport lombok.Setter;\n\n@Entity\n@Getter\n@Setter\npublic class SubwayStations {\n\n    @Id\n    private String stationcode; //역 코드 id\n\n    private String stationname; //역 이름\n    private String stationeng; //역 이름 영문\n    private String linenum; //역에 지나는 호선\n    private String outercode; //역의 외부코드\n    /*역에 지나는 호선이 여러개인 경우, 지나는 호선 개수만큼 하나의 역에 여러개의 외부코드가 있음.\n     현재 저장된 방식은 하나의 역마다 여러개의 외부코드가 있을 경우 여러 행에 저장됨.\n     예시)\n     0150\t서울역\tSeoul Station\t1호선\t133\n     0426\t서울역\tSeoul Station\t4호선\t426\n     1251\t서울역\tSeoul Station\t경의선\tP313\n     4201\t서울역\tSeoul Station\t공항철도\tA01\n     */\n}\n",
            "TrainInfo.java": "package com.example.subway.domain;\n\nimport jakarta.persistence.*;\nimport lombok.Getter;\nimport lombok.Setter;\nimport java.time.LocalDateTime;\n\n@Entity\n@Getter\n@Setter\npublic class TrainInfo {\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n\n    private String trainNo;        // 열차번호\n    private String upDown;         // 상하선 정보 (SubwayStations의 upDown과 동일)\n    private String expressYn;      // 막차 여부\n    private String currentStation; // 현재역\n    private String endStation;     // 종착역\n\n    // ------------------- [새로 추가된 부분] -------------------\n    private String lineNum;        // 소속된 호선\n    // -------------------------------------------------------\n\n    @Lob\n    private String stationsJson;   // 열차가 지나갈 역 목록 (JSON)\n\n    private LocalDateTime updateTime; // 마지막 갱신 시간\n}\n"
        }
    },
    "dto": {
        "__files__": {
            "StationTrainResponse.java": "package com.example.subway.dto;\n\nimport lombok.AllArgsConstructor;\nimport lombok.Getter;\n\n@Getter\n@AllArgsConstructor\npublic class StationTrainResponse {\n    private String trainNo;\n    private String upDown;\n    private String expressYn;\n    private String currentStation;\n    private String endStation;\n    private int remainingStations; // 남은 정거장 수\n}\n"
        }
    },
    "repository": {
        "__files__": {
            "SubwayDataRepository.java": "package com.example.subway.repository;\n\nimport com.example.subway.domain.SubwayData;\nimport org.springframework.data.jpa.repository.JpaRepository;\n\npublic interface SubwayDataRepository extends JpaRepository<SubwayData, Long> {\n    // line별로 가져오기\n    // List<SubwayData> findByLinenum(String linenum);\n}\n",
            "SubwayStationRepository.java": "package com.example.subway.repository;\n\nimport com.example.subway.domain.SubwayStations;\nimport org.springframework.data.jpa.repository.JpaRepository;\n\npublic interface SubwayStationRepository extends JpaRepository<SubwayStations, String> {\n    // stationcode(String) 이 PK\n}\n",
            "TrainInfoRepository.java": "// TrainInfoRepository.java\npackage com.example.subway.repository;\n\nimport com.example.subway.domain.TrainInfo;\nimport org.springframework.data.jpa.repository.JpaRepository;\n\nimport java.util.List;\nimport java.util.Optional;\n\npublic interface TrainInfoRepository extends JpaRepository<TrainInfo, Long> {\n    Optional<TrainInfo> findByTrainNo(String trainNo);\n\n    // 추가: lineNum 기준으로 조회\n    List<TrainInfo> findByLineNum(String lineNum);\n}\n"
        }
    },
    "service": {
        "__files__": {
            "SubwayGraphService.java": "package com.example.subway.service;\n\nimport com.example.subway.domain.SubwayData;\nimport com.example.subway.repository.SubwayDataRepository;\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.stereotype.Service;\n\nimport java.util.*;\n\n@Slf4j\n@Service\npublic class SubwayGraphService {\n\n    private final SubwayDataRepository subwayDataRepository;\n\n    public SubwayGraphService(SubwayDataRepository subwayDataRepository) {\n        this.subwayDataRepository = subwayDataRepository;\n    }\n\n    // 특정 호선에 대해 인접 리스트 형태의 그래프를 구성\n    public Map<String, List<String>> buildGraph(String lineNum) {\n        // 1) DB에서 전체 SubwayData 로딩\n        List<SubwayData> dataList = subwayDataRepository.findAll();\n\n        // 2) 로드된 모든 레코드 로그 출력 (디버그용)\n        log.info(\"===== [SubwayData 테이블 전체 조회 결과] =====\");\n        for (SubwayData data : dataList) {\n            log.info(\"Row => id={}, linenum={}, frontStationname={}, frontOutercode={}, backStationname={}, backOutercode={}\",\n                    data.getId(),\n                    data.getLinenum(),\n                    data.getFrontStationname(),\n                    data.getFrontOutercode(),\n                    data.getBackStationname(),\n                    data.getBackOutercode()\n            );\n        }\n        log.info(\"===== [총 {}개 레코드 조회 완료] =====\", dataList.size());\n\n        // 3) lineNum에 해당하는 레코드만 골라서 그래프 구성\n        Map<String, List<String>> graph = new HashMap<>();\n        for (SubwayData data : dataList) {\n            // lineNum 일치하는 것만 처리\n            if (!data.getLinenum().equals(lineNum)) {\n                continue;\n            }\n\n            String front = data.getFrontStationname();\n            String back  = data.getBackStationname();\n\n            // 인접 리스트에 추가\n            graph.computeIfAbsent(front, k -> new ArrayList<>()).add(back);\n            graph.computeIfAbsent(back, k -> new ArrayList<>()).add(front);\n        }\n\n        return graph;\n    }\n\n    // BFS로 start~end 경로 찾기\n    public List<String> bfsPath(Map<String, List<String>> graph, String start, String end) {\n        log.info(\"----- BFS START: from '{}' to '{}' -----\", start, end);\n\n        // 그래프에 start나 end가 없으면 빈 리스트 반환\n        if (!graph.containsKey(start) || !graph.containsKey(end)) {\n            log.warn(\"[BFS] start='{}' 혹은 end='{}'가 graph에 존재하지 않습니다. 빈 경로 반환.\", start, end);\n            return Collections.emptyList();\n        }\n\n        Set<String> visited = new HashSet<>();\n        Map<String, String> parent = new HashMap<>();\n        Queue<String> queue = new LinkedList<>();\n\n        visited.add(start);\n        parent.put(start, null);\n        queue.offer(start);\n\n        while (!queue.isEmpty()) {\n            String current = queue.poll();\n            log.debug(\"[BFS] 현재 방문 노드: {}\", current);\n\n            // end 지점에 도달\n            if (current.equals(end)) {\n                log.debug(\"[BFS] 목적지 '{}'에 도달했습니다.\", end);\n                break;\n            }\n\n            List<String> neighbors = graph.get(current);\n            if (neighbors == null) {\n                continue;\n            }\n            for (String neighbor : neighbors) {\n                if (!visited.contains(neighbor)) {\n                    visited.add(neighbor);\n                    parent.put(neighbor, current);\n                    queue.offer(neighbor);\n                    log.debug(\"[BFS] 새로운 이웃 '{}' 발견 -> queue에 추가\", neighbor);\n                }\n            }\n        }\n\n        // end 노드가 parent에 없으면 경로가 없다는 뜻\n        if (!parent.containsKey(end)) {\n            log.warn(\"[BFS] '{}'로 가는 경로를 찾지 못했습니다. 빈 경로 반환.\", end);\n            return Collections.emptyList();\n        }\n\n        // parent 맵을 역추적\n        List<String> path = new ArrayList<>();\n        String node = end;\n        while (node != null) {\n            path.add(node);\n            node = parent.get(node);\n        }\n        Collections.reverse(path);\n\n        log.info(\"[BFS] '{}' -> '{}' 경로: {}\", start, end, path);\n        return path;\n    }\n}\n",
            "SubwaySyncService.java": "package com.example.subway.service;\n\nimport com.example.subway.domain.TrainInfo;\nimport com.example.subway.repository.TrainInfoRepository;\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.scheduling.annotation.Scheduled;\nimport org.springframework.stereotype.Service;\nimport org.w3c.dom.*;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport java.net.URL;\nimport java.net.URLEncoder;\nimport java.time.LocalDateTime;\nimport java.util.*;\n\n@Slf4j\n@Service\npublic class SubwaySyncService {\n\n    private final TrainInfoRepository trainInfoRepository;\n    private final SubwayGraphService subwayGraphService;\n\n    // 예시 API 키 (테스트용)\n    private static final String API_KEY = \"755455636167793236306850475a51\";\n    // swopenAPI: (API_KEY, 노선명) 순서로 URL 구성\n    private static final String SUBWAY_API_URL\n            = \"http://swopenAPI.seoul.go.kr/api/subway/%s/xml/realtimePosition/0/100/%s\";\n\n    public SubwaySyncService(TrainInfoRepository trainInfoRepository,\n                             SubwayGraphService subwayGraphService) {\n        this.trainInfoRepository = trainInfoRepository;\n        this.subwayGraphService  = subwayGraphService;\n    }\n\n    /**\n     * 지정된 주기로 1~2호선 열차정보를 동기화 (테스트 예시)\n     * 실제로는 1~9호선을 순회하도록 수정 가능\n     */\n    @Scheduled(fixedDelayString = \"${myapp.schedule.subway-refresh}\")\n    public void syncTrains() {\n        for (int line = 1; line <= 9; line++) {\n            String lineNum = line + \"호선\";\n            try {\n                // URL 인코딩\n                String lineNameEncoded = URLEncoder.encode(lineNum, \"UTF-8\");\n                syncLine(lineNameEncoded, lineNum);\n            } catch (Exception e) {\n                log.error(\"Failed to sync line {}: {}\", lineNum, e.getMessage(), e);\n            }   \n        }\n    }\n\n    /**\n     * 특정 호선(lineNameEncoded, lineNum)에 대한 열차정보 동기화 + DB 정리 로직\n     */\n    private void syncLine(String lineNameEncoded, String lineNum) throws Exception {\n        // 1) API 호출\n        String apiUrl = String.format(SUBWAY_API_URL, API_KEY, lineNameEncoded);\n        Document doc = DocumentBuilderFactory.newInstance()\n                .newDocumentBuilder()\n                .parse(new URL(apiUrl).openStream());\n        doc.getDocumentElement().normalize();\n\n        NodeList rowList = doc.getElementsByTagName(\"row\");\n        if (rowList.getLength() == 0) {\n            log.info(\"[INFO] {}: 열차 정보가 없습니다.\", lineNum);\n            // 혹시 필요하다면, 여기서 해당 호선의 모든 열차 삭제 로직을 추가해도 됨.\n            return;\n        }\n\n        // 2) 이 노선(lineNum)에 대한 그래프 구성 (BFS 용)\n        Map<String, List<String>> graph = subwayGraphService.buildGraph(lineNum);\n\n        // 3) 이번 동기화에서 발견된 trainNo를 추적하기 위한 Set\n        Set<String> fetchedTrainNos = new HashSet<>();\n\n        // 4) API 응답(rowList) 순회 후, DB Insert/Update\n        for (int i = 0; i < rowList.getLength(); i++) {\n            Node row = rowList.item(i);\n            if (row.getNodeType() != Node.ELEMENT_NODE) {\n                continue;\n            }\n            Element element = (Element) row;\n\n            // 열차번호\n            String trainNo  = getTagValue(element, \"trainNo\");\n            // 상/하행\n            String upDown   = getTagValue(element, \"updnLine\");\n            // 막차 여부 (예시)\n            String expressYn= getTagValue(element, \"expressyn\");\n            // 현재역\n            String currStatn= getTagValue(element, \"statnNm\");\n            // 종착역\n            String endStatn = getTagValue(element, \"statnTnm\");\n\n            // 필수 정보 누락 시 스킵\n            if (trainNo == null || currStatn == null || endStatn == null) {\n                log.warn(\"Skipping row due to null values: trainNo={}, currStatn={}, endStatn={}\",\n                        trainNo, currStatn, endStatn);\n                continue;\n            }\n\n            // 새로 발견된 trainNo 기록\n            fetchedTrainNos.add(trainNo);\n\n            // DB에서 trainNo 존재 여부 확인\n            Optional<TrainInfo> optTrain = trainInfoRepository.findByTrainNo(trainNo);\n            TrainInfo train;\n            if (optTrain.isEmpty()) {\n                // --- [새 열차] ---\n                train = new TrainInfo();\n                train.setTrainNo(trainNo);\n                train.setUpDown(upDown);\n                train.setExpressYn(expressYn);\n                train.setCurrentStation(currStatn);\n                train.setEndStation(endStatn);\n                // [추가] 호선 저장\n                train.setLineNum(lineNum);\n\n                // BFS로 현재역~종착역 사이 경로 계산\n                List<String> path = subwayGraphService.bfsPath(graph, currStatn, endStatn);\n                log.debug(\"[NEW TRAIN] BFS path: {}\", path);\n\n                // path를 JSON 문자열로 변환해서 저장\n                train.setStationsJson(toJsonString(path));\n                train.setUpdateTime(LocalDateTime.now());\n                trainInfoRepository.save(train);\n\n                log.info(\"[NEW TRAIN] {} - {} ( {} -> {} )\", trainNo, lineNum, currStatn, endStatn);\n\n            } else {\n                // --- [기존 열차 업데이트] ---\n                train = optTrain.get();\n                train.setUpDown(upDown);\n                train.setExpressYn(expressYn);\n                train.setCurrentStation(currStatn);\n                train.setEndStation(endStatn);\n                train.setLineNum(lineNum);\n\n                // 기존에 저장된 JSON 경로에서 \"이미 지난 역\"을 제거하는 로직\n                List<String> path = fromJsonString(train.getStationsJson());\n                if (path != null && !path.isEmpty()) {\n                    int currIdx = path.indexOf(currStatn);\n                    // 현재역보다 앞에 있는 역들은 지난 것으로 보고 제거\n                    if (currIdx > 0) {\n                        for (int idx = 0; idx < currIdx; idx++) {\n                            path.set(idx, null);\n                        }\n                        path.removeIf(Objects::isNull);\n                    }\n                    train.setStationsJson(toJsonString(path));\n                }\n\n                train.setUpdateTime(LocalDateTime.now());\n                trainInfoRepository.save(train);\n\n                log.info(\"[UPDATE TRAIN] {} - {} (현재역: {})\", trainNo, lineNum, currStatn);\n            }\n        }\n\n        // 5) === [사라진 열차] 정리 로직 ===\n        //    이번 동기화에서 발견되지 않은(= fetchedTrainNos에 없는) 열차를 DB에서 삭제\n        List<TrainInfo> existingTrains = trainInfoRepository.findByLineNum(lineNum);\n        for (TrainInfo t : existingTrains) {\n            // 해당 lineNum에 속하지만, 이번 동기화에서 발견되지 않은 trainNo\n            if (!fetchedTrainNos.contains(t.getTrainNo())) {\n                // 운행 종료된 것으로 판단하여 DB에서 제거\n                trainInfoRepository.delete(t);\n                log.info(\"[DELETE TRAIN] {} - {} (운행 종료)\", t.getTrainNo(), lineNum);\n            }\n        }\n    }\n\n    /**\n     * XML Element에서 특정 tag 텍스트 값을 추출하는 헬퍼 메서드\n     */\n    private String getTagValue(Element element, String tag) {\n        NodeList list = element.getElementsByTagName(tag);\n        if (list.getLength() == 0) {\n            return null;\n        }\n        return list.item(0).getTextContent();\n    }\n\n    /**\n     * List<String> -> JSON 문자열 변환 (간단 버전)\n     * 예: [\"서울역\",\"시청역\",\"종각역\"]\n     */\n    private String toJsonString(List<String> list) {\n        if (list == null) return \"[]\";\n        return \"[\" + String.join(\",\",\n                list.stream().map(s -> \"\\\"\" + s + \"\\\"\").toList()\n        ) + \"]\";\n    }\n\n    /**\n     * JSON 문자열 -> List<String> 변환 (간단 버전)\n     */\n    private List<String> fromJsonString(String json) {\n        if (json == null || json.isBlank()) {\n            return new ArrayList<>();\n        }\n        String trimmed = json.trim();\n        if (trimmed.startsWith(\"[\") && trimmed.endsWith(\"]\")) {\n            trimmed = trimmed.substring(1, trimmed.length() - 1).trim();\n            if (trimmed.isEmpty()) {\n                return new ArrayList<>();\n            }\n            List<String> result = new ArrayList<>();\n            String[] tokens = trimmed.split(\",\");\n            for (String t : tokens) {\n                String val = t.trim().replaceAll(\"\\\"\", \"\");\n                result.add(val);\n            }\n            return result;\n        }\n        return new ArrayList<>();\n    }\n}\n"
        }
    }
}