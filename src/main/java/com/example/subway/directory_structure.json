{
    "__files__": {
        "codes.py": null,
        "directory_structure.json": null,
        "SubwayApplication.java": "package com.example.subway;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.scheduling.annotation.EnableScheduling;\n\n@SpringBootApplication\n@EnableScheduling  // 스케줄링 기능\npublic class SubwayApplication {\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(SubwayApplication.class, args);\n\t}\n}\n"
    },
    "config": {
        "__files__": {
            "DatabaseInitializer.java": "package com.example.subway.config;\n\nimport com.example.subway.repository.TrainInfoRepository;\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.stereotype.Component;\nimport jakarta.annotation.PostConstruct;\n\n/**\n * 애플리케이션이 시작될 때 train_info 테이블을 초기화(전량 삭제)하는 예시\n */\n@Slf4j\n@Component\npublic class DatabaseInitializer {\n\n    private final TrainInfoRepository trainInfoRepository;\n\n    public DatabaseInitializer(TrainInfoRepository trainInfoRepository) {\n        this.trainInfoRepository = trainInfoRepository;\n    }\n\n    @PostConstruct\n    public void initDatabase() {\n        // (1) 기존 train_info 내용 모두 삭제\n        trainInfoRepository.deleteAll();\n\n        // (2) 필요한 경우, 초기 데이터 Insert 가능\n        // ex) trainInfoRepository.save(...);\n\n        log.info(\"[INIT] train_info 테이블을 초기화(deleteAll)했습니다.\");\n    }\n}\n",
            "SecurityConfig.java": "package com.example.subway.config;\n\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.security.config.Customizer;\nimport org.springframework.security.config.annotation.web.builders.HttpSecurity;\nimport org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;\nimport org.springframework.security.crypto.password.PasswordEncoder;\nimport org.springframework.security.web.SecurityFilterChain;\n\n@Configuration\npublic class SecurityConfig {\n    @Bean\n    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {\n        // CSRF 비활성화 및 모든 요청 허용 (간단 예시)\n        http.csrf(csrf->csrf.disable())\n                .authorizeHttpRequests(authorize -> authorize\n                        .requestMatchers(\"/api/users/**\").permitAll()\n                        .anyRequest().permitAll()\n                )\n                .httpBasic(Customizer.withDefaults());\n        return http.build();\n    }\n\n    @Bean\n    public PasswordEncoder passwordEncoder() {\n        return new BCryptPasswordEncoder();\n    }\n}\n"
        }
    },
    "controller": {
        "__files__": {
            "StationController.java": "package com.example.subway.controller;\n\nimport com.example.subway.domain.TrainInfo;\nimport com.example.subway.dto.StationTrainResponse;\nimport com.example.subway.repository.TrainInfoRepository;\nimport com.fasterxml.jackson.core.type.TypeReference;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.PathVariable;\nimport org.springframework.web.bind.annotation.RestController;\n\nimport java.io.IOException;\nimport java.util.*;\n\n@Slf4j\n@RestController\npublic class StationController {\n\n    private final TrainInfoRepository trainInfoRepository;\n    private final ObjectMapper objectMapper = new ObjectMapper();\n\n    public StationController(TrainInfoRepository trainInfoRepository) {\n        this.trainInfoRepository = trainInfoRepository;\n    }\n\n    @GetMapping(\"/api/station/{stationName}\")\n    public List<StationTrainResponse> getTrainsPassingStation(@PathVariable(\"stationName\") String stationName) {\n        List<TrainInfo> allTrains = trainInfoRepository.findAll();\n        List<StationTrainResponse> result = new ArrayList<>();\n\n        for (TrainInfo train : allTrains) {\n            // JSON 형식의 역 목록을 List<String>으로 파싱\n            List<String> path = convertJsonToList(train.getStationsJson());\n            if (path == null) {\n                continue;\n            }\n\n            // 요청받은 stationName의 인덱스 확인\n            int stationIndex = path.indexOf(stationName);\n            if (stationIndex == -1) {\n                continue;\n            }\n\n            // 현재역의 인덱스 확인\n            int currIndex = path.indexOf(train.getCurrentStation());\n            if (currIndex == -1) {\n                continue;\n            }\n\n            int remainingStations = stationIndex - currIndex;\n            if (remainingStations < 0) {\n                continue;\n            }\n\n            // lstcarAt을 boolean으로 변환 (\"1\"이면 true, 그 외에는 false)\n            boolean isLastTrain = \"1\".equals(train.getLstcarAt());\n\n            StationTrainResponse dto = new StationTrainResponse(\n                    train.getTrainNo(),\n                    train.getUpDown(),\n                    isLastTrain,\n                    train.getCurrentStation(),\n                    train.getEndStation(),\n                    remainingStations,\n                    train.getLineNum()\n            );\n            result.add(dto);\n        }\n\n        // 남은 정거장 수 기준 오름차순 정렬\n        result.sort(Comparator.comparingInt(StationTrainResponse::getRemainingStations));\n        return result;\n    }\n\n    /**\n     * JSON 문자열을 List<String>으로 변환하는 헬퍼 메서드\n     */\n    private List<String> convertJsonToList(String json) {\n        if (json == null || json.isEmpty()) {\n            return null;\n        }\n        try {\n            return objectMapper.readValue(json, new TypeReference<List<String>>() {});\n        } catch (IOException e) {\n            log.error(\"Failed to parse JSON string: {}\", json, e);\n            return null;\n        }\n    }\n}\n",
            "UserController.java": "package com.example.subway.controller;\n\nimport com.example.subway.domain.User;\nimport com.example.subway.dto.UserRegistrationRequest;\nimport com.example.subway.dto.UserLoginRequest;\nimport com.example.subway.dto.UserResponse;\nimport com.example.subway.service.UserService;\nimport org.springframework.http.ResponseEntity;\nimport org.springframework.web.bind.annotation.*;\n\n@RestController\n@RequestMapping(\"/api/users\")\npublic class UserController {\n    private final UserService userService;\n\n    public UserController(UserService userService) {\n        this.userService = userService;\n    }\n\n    // 회원가입 엔드포인트\n    @PostMapping(\"/register\")\n    public ResponseEntity<UserResponse> register(@RequestBody UserRegistrationRequest request) {\n        User user = userService.registerUser(request);\n        return ResponseEntity.ok(new UserResponse(user.getId(), user.getUsername(), user.getWorkStation(), user.getAlertThreshold()));\n    }\n\n    // 로그인 엔드포인트\n    @PostMapping(\"/login\")\n    public ResponseEntity<UserResponse> login(@RequestBody UserLoginRequest request) {\n        return userService.authenticate(request)\n                .map(user -> ResponseEntity.ok(new UserResponse(user.getId(), user.getUsername(), user.getWorkStation(), user.getAlertThreshold())))\n                .orElse(ResponseEntity.status(401).build());\n    }\n\n    // 프로필 업데이트 (근무역, 알림 정거장 수 변경)\n    @PutMapping(\"/{userId}/profile\")\n    public ResponseEntity<UserResponse> updateProfile(@PathVariable Long userId,\n                                                      @RequestBody UserRegistrationRequest request) {\n        User updatedUser = userService.updateUserProfile(userId, request.getWorkStation(), request.getAlertThreshold());\n        return ResponseEntity.ok(new UserResponse(updatedUser.getId(), updatedUser.getUsername(), updatedUser.getWorkStation(), updatedUser.getAlertThreshold()));\n    }\n}\n"
        }
    },
    "domain": {
        "__files__": {
            "SubwayData.java": "package com.example.subway.domain;\n\nimport jakarta.persistence.*;\nimport lombok.Getter;\nimport lombok.Setter;\n\n@Entity\n@Getter\n@Setter\npublic class SubwayData {\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id; // 고유 id\n\n    private String linenum; // 몇호선에 존재하는 관계인지\n\n    /* 연결관계는 앞 > 뒤로 연결됨, 앞 > 뒤의 연결관계 방향에 따라 upDown 상행 하행을 저장 */\n    private String frontStationname; // 앞 역 이름\n    private String frontOutercode;  // 앞 역 외부코드\n\n    private String backStationname;  // 뒷 역 이름\n    private String backOutercode;    // 뒷 역 외부코드\n\n    private String upDown; // 상행 하행 저장정보. 상행(내선):0, 하행(외선):1\n\n    // 급행 노선 여부: \"Y\"이면 급행, \"N\"이면 일반 노선\n    private String expressYn;\n}\n",
            "SubwayStations.java": "package com.example.subway.domain;\n\nimport jakarta.persistence.Entity;\nimport jakarta.persistence.Id;\nimport lombok.Getter;\nimport lombok.Setter;\n\n@Entity\n@Getter\n@Setter\npublic class SubwayStations {\n\n    @Id\n    private String stationcode; //역 코드 id\n\n    private String stationname; //역 이름\n    private String stationeng; //역 이름 영문\n    private String linenum; //역에 지나는 호선\n    private String outercode; //역의 외부코드\n    /*역에 지나는 호선이 여러개인 경우, 지나는 호선 개수만큼 하나의 역에 여러개의 외부코드가 있음.\n     현재 저장된 방식은 하나의 역마다 여러개의 외부코드가 있을 경우 여러 행에 저장됨.\n     예시)\n     0150\t서울역\tSeoul Station\t1호선\t133\n     0426\t서울역\tSeoul Station\t4호선\t426\n     1251\t서울역\tSeoul Station\t경의선\tP313\n     4201\t서울역\tSeoul Station\t공항철도\tA01\n     */\n}\n",
            "TrainInfo.java": "package com.example.subway.domain;\n\nimport jakarta.persistence.*;\nimport lombok.Getter;\nimport lombok.Setter;\nimport java.time.LocalDateTime;\n\n@Entity\n@Getter\n@Setter\npublic class TrainInfo {\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n\n    // API에서 받아오는 필드들\n    private String subwayId;     // 지하철호선ID (예: 1001, 1063 등)\n    private String statnId;      // 지하철역ID (현재역 ID)\n    private String trainNo;      // 열차번호\n    private String lastRecptnDt; // 최종수신날짜\n    private String recptnDt;     // 최종수신시간\n    private String upDown;       // 상하행 정보 (0: 상행/내선, 1: 하행/외선)\n    private String trainSttus;   // 열차상태구분 (0:진입, 1:도착, 2:출발, 3:전역출발)\n    private String directAt;     // 급행여부 (1:급행, 0:아님, 7:특급)\n    private String lstcarAt;     // 막차여부 (1:막차, 0:아님)\n\n    // API에서 받아온 현재역, 종착역명에서 소괄호 제거 후 저장\n    private String currentStation; // 현재역 (statnNm, 소괄호 제거)\n    private String statnTid;       // 종착지하철역ID\n    private String endStation;     // 종착역 (statnTnm, 소괄호 제거)\n\n    // 추가 정보: DB에서 사용하는 노선명 (예: \"1호선\", \"경의선\" 등)\n    private String lineNum;\n\n    @Lob\n    private String stationsJson;   // 열차가 지나갈 역 목록 (JSON)\n\n    private LocalDateTime updateTime; // 마지막 갱신 시간\n}\n",
            "User.java": "package com.example.subway.domain;\n\nimport jakarta.persistence.*;\nimport lombok.Getter;\nimport lombok.Setter;\n\n@Entity\n@Getter\n@Setter\npublic class User {\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n\n    // 아이디(유니크)\n    @Column(unique = true, nullable = false)\n    private String username;\n\n    // 비밀번호 (암호화하여 저장)\n    @Column(nullable = false)\n    private String password;\n\n    // 사용자의 근무역\n    private String workStation;\n\n    // 열차가 도착하기 전에 알림을 받을 정거장 수\n    private int alertThreshold;\n}\n"
        }
    },
    "dto": {
        "__files__": {
            "StationTrainResponse.java": "package com.example.subway.dto;\n\nimport lombok.AllArgsConstructor;\nimport lombok.Getter;\n\n@Getter\n@AllArgsConstructor\npublic class StationTrainResponse {\n    private String trainNo;\n    private String upDown;\n    private boolean lastTrain;         // 막차 여부 (true: 막차, false: 아님)\n    private String currentStation;\n    private String endStation;\n    private int remainingStations;     // 남은 정거장 수\n    private String lineNum;            // 열차가 운행 중인 호선 정보\n}\n",
            "UserLoginRequest.java": "package com.example.subway.dto;\n\nimport lombok.Getter;\nimport lombok.Setter;\n\n@Getter\n@Setter\npublic class UserLoginRequest {\n    private String username;\n    private String password;\n}\n",
            "UserRegistrationRequest.java": "package com.example.subway.dto;\n\nimport lombok.Getter;\nimport lombok.Setter;\n\n@Getter\n@Setter\npublic class UserRegistrationRequest {\n    private String username;\n    private String password;\n    private String workStation;\n    private int alertThreshold;\n}\n",
            "UserResponse.java": "package com.example.subway.dto;\n\nimport lombok.AllArgsConstructor;\nimport lombok.Getter;\n\n@Getter\n@AllArgsConstructor\npublic class UserResponse {\n    private Long id;\n    private String username;\n    private String workStation;\n    private int alertThreshold;\n}\n"
        }
    },
    "repository": {
        "__files__": {
            "SubwayDataRepository.java": "package com.example.subway.repository;\n\nimport com.example.subway.domain.SubwayData;\nimport org.springframework.data.jpa.repository.JpaRepository;\n\npublic interface SubwayDataRepository extends JpaRepository<SubwayData, Long> {\n    // line별로 가져오기\n    // List<SubwayData> findByLinenum(String linenum);\n}\n",
            "SubwayStationRepository.java": "package com.example.subway.repository;\n\nimport com.example.subway.domain.SubwayStations;\nimport org.springframework.data.jpa.repository.JpaRepository;\n\npublic interface SubwayStationRepository extends JpaRepository<SubwayStations, String> {\n    // stationcode(String) 이 PK\n\n    // 기존의 findByStationname 메서드 대신,\n    // 해당 역이 존재하는지만 확인하는 메서드를 추가합니다.\n    boolean existsByStationname(String stationname);\n}\n",
            "TrainInfoRepository.java": "// TrainInfoRepository.java\npackage com.example.subway.repository;\n\nimport com.example.subway.domain.TrainInfo;\nimport org.springframework.data.jpa.repository.JpaRepository;\n\nimport java.util.List;\nimport java.util.Optional;\n\npublic interface TrainInfoRepository extends JpaRepository<TrainInfo, Long> {\n    Optional<TrainInfo> findByTrainNo(String trainNo);\n\n    // 추가: lineNum 기준으로 조회\n    List<TrainInfo> findByLineNum(String lineNum);\n}\n",
            "UserRepository.java": "package com.example.subway.repository;\n\nimport com.example.subway.domain.User;\nimport org.springframework.data.jpa.repository.JpaRepository;\nimport java.util.Optional;\n\npublic interface UserRepository extends JpaRepository<User, Long> {\n    Optional<User> findByUsername(String username);\n}\n"
        }
    },
    "service": {
        "__files__": {
            "NotificationService.java": "package com.example.subway.service;\n\nimport com.example.subway.domain.TrainInfo;\nimport com.example.subway.domain.User;\nimport com.example.subway.repository.UserRepository;\nimport com.fasterxml.jackson.core.type.TypeReference;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport com.fasterxml.jackson.databind.SerializationFeature;\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.stereotype.Service;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.time.LocalDateTime;\nimport java.util.*;\n\n@Slf4j\n@Service\npublic class NotificationService {\n\n    private final UserRepository userRepository;\n    private final ObjectMapper objectMapper = new ObjectMapper();\n    private static final String ALERT_FILE = \"alert.json\"; // 알림 기록 파일\n\n    public NotificationService(UserRepository userRepository) {\n        this.userRepository = userRepository;\n    }\n\n    /**\n     * 막차 열차에 대해, 해당 열차의 stationsJson(경로)에서\n     * 현재역부터 사용자의 근무역까지 남은 정거장이 사용자가 설정한 alertThreshold와 같으면\n     * 알림 이벤트를 alert.json 파일에 기록합니다.\n     */\n    public void checkAndSendAlerts(TrainInfo train) {\n        // 막차 여부 확인: \"1\"이면 막차임\n        if (!\"1\".equals(train.getLstcarAt())) {\n            return;\n        }\n\n        List<String> route = parseRoute(train.getStationsJson());\n        if (route == null || route.isEmpty()) {\n            return;\n        }\n\n        int currIndex = route.indexOf(train.getCurrentStation());\n        if (currIndex == -1) {\n            return;\n        }\n\n        List<User> users = userRepository.findAll();\n        for (User user : users) {\n            if (user.getWorkStation() == null) continue;\n\n            int stationIndex = route.indexOf(user.getWorkStation());\n            if (stationIndex == -1) continue;\n\n            int remaining = stationIndex - currIndex;\n            if (remaining == user.getAlertThreshold()) {\n                System.out.println(\"실행요\");\n                // 조건에 맞는 경우 alert.json 파일에 알림 이벤트 기록\n                logAlertEvent(user, train, remaining);\n            }\n        }\n    }\n\n    // stationsJson 문자열을 List<String>으로 파싱하는 헬퍼 메서드\n    private List<String> parseRoute(String json) {\n        if (json == null || json.isBlank()) {\n            return null;\n        }\n        try {\n            return objectMapper.readValue(json, new TypeReference<List<String>>() {});\n        } catch (IOException e) {\n            log.error(\"Failed to parse route JSON: {}\", json, e);\n            return null;\n        }\n    }\n\n    // 알림 이벤트를 alert.json 파일에 기록하는 헬퍼 메서드\n    private void logAlertEvent(User user, TrainInfo train, int remaining) {\n        ObjectMapper mapper = new ObjectMapper().enable(SerializationFeature.INDENT_OUTPUT);\n        List<Map<String, Object>> alertList = new ArrayList<>();\n        File file = new File(ALERT_FILE);\n\n        // 기존 alert.json 파일이 존재하면 기존 기록을 불러옴\n        if (file.exists()) {\n            try {\n                alertList = mapper.readValue(file, new TypeReference<List<Map<String, Object>>>() {});\n            } catch (IOException e) {\n                log.error(\"alert.json 파일 읽기 실패: {}\", e.getMessage(), e);\n            }\n        }\n\n        // 새로운 알림 기록 생성\n        Map<String, Object> record = new HashMap<>();\n        record.put(\"timestamp\", LocalDateTime.now().toString());\n        record.put(\"username\", user.getUsername());\n        record.put(\"trainNo\", train.getTrainNo());\n        record.put(\"workStation\", user.getWorkStation());\n        record.put(\"remainingStops\", remaining);\n        record.put(\"message\", \"Alert: Last train \" + train.getTrainNo() +\n                \" will arrive at your station '\" + user.getWorkStation() + \"' in \" + remaining + \" stops.\");\n\n        alertList.add(record);\n\n        // alert.json 파일에 기록 저장\n        try {\n            mapper.writeValue(file, alertList);\n            log.info(\"alert.json 파일에 알림 기록 완료: {}\", record);\n        } catch (IOException e) {\n            log.error(\"alert.json 파일 쓰기 실패: {}\", e.getMessage(), e);\n        }\n    }\n}\n",
            "SubwayGraphService.java": "package com.example.subway.service;\n\nimport com.example.subway.domain.SubwayData;\nimport com.example.subway.repository.SubwayDataRepository;\nimport com.fasterxml.jackson.core.type.TypeReference;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport com.fasterxml.jackson.databind.SerializationFeature;\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.stereotype.Service;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.time.LocalDateTime;\nimport java.util.*;\n\n@Slf4j\n@Service\npublic class SubwayGraphService {\n\n    private final SubwayDataRepository subwayDataRepository;\n\n    // BFS 실패 건을 기록할 JSON 파일 경로\n    private static final String FAILED_BFS_FILE = \"bfs_failures.json\";\n\n    public SubwayGraphService(SubwayDataRepository subwayDataRepository) {\n        this.subwayDataRepository = subwayDataRepository;\n    }\n\n    /**\n     * 특정 호선(lineNum)에 대응하는 인접 그래프를 생성 (일반 노선 기준).\n     */\n    public Map<String, List<String>> buildGraph(String lineNum) {\n        return buildGraph(lineNum, false);\n    }\n\n    /**\n     * 특정 호선(lineNum)에 대해, expressOnly 플래그에 따라\n     * 일반 노선 / 급행 노선만 필터링하여 인접 그래프를 생성.\n     */\n    public Map<String, List<String>> buildGraph(String lineNum, boolean expressOnly) {\n        List<SubwayData> dataList = subwayDataRepository.findAll();\n\n        Map<String, List<String>> graph = new HashMap<>();\n        for (SubwayData data : dataList) {\n            // 1) 호선 필터\n            if (!data.getLinenum().equals(lineNum)) {\n                continue;\n            }\n            // 2) 급행 여부 필터\n            if (expressOnly && !\"Y\".equalsIgnoreCase(data.getExpressYn())) {\n                continue;\n            }\n            if (!expressOnly && \"Y\".equalsIgnoreCase(data.getExpressYn())) {\n                continue;\n            }\n\n            String front = data.getFrontStationname();\n            String back  = data.getBackStationname();\n\n            // 양방향 그래프 구성\n            graph.computeIfAbsent(front, k -> new ArrayList<>()).add(back);\n            graph.computeIfAbsent(back, k -> new ArrayList<>()).add(front);\n        }\n        return graph;\n    }\n\n    /**\n     * BFS로 start에서 end로 가는 경로를 탐색 (호선 정보를 알 수 없을 때 오버로드).\n     * 기존 코드를 깨지 않기 위해 남겨둔 메서드입니다.\n     */\n    public List<String> bfsPath(Map<String, List<String>> graph, String start, String end) {\n        // 호선 정보를 알 수 없으면 임시로 \"UNKNOWN_LINE\" 사용\n        return bfsPath(graph, start, end, \"UNKNOWN_LINE\");\n    }\n\n    /**\n     * BFS로 start에서 end로 가는 경로를 탐색 (호선(lineNum) 포함).\n     * 실패 시 \"왜 못찾았는지(reason)\" + \"어디까지 탐색했는지(visited)\" + \"호선(lineNum)\"을\n     * JSON 파일(Pretty Print)로 기록합니다.\n     */\n    public List<String> bfsPath(Map<String, List<String>> graph, String start, String end, String lineNum) {\n        log.info(\"----- BFS START [lineNum={}] from '{}' to '{}' -----\", lineNum, start, end);\n\n        // (1) start/end 노드가 그래프에 없는 경우 -> 실패 기록\n        if (!graph.containsKey(start) || !graph.containsKey(end)) {\n            log.warn(\"[BFS] start='{}' 혹은 end='{}'가 lineNum='{}' 그래프에 없습니다.\", start, end, lineNum);\n            logFailedBfs(start, end, lineNum,\n                    \"Start 혹은 End 노드가 그래프에 존재하지 않음\",\n                    Collections.emptySet());\n            return Collections.emptyList();\n        }\n\n        // (2) BFS 준비\n        Set<String> visited = new HashSet<>();\n        Map<String, String> parent = new HashMap<>();\n        Queue<String> queue = new LinkedList<>();\n\n        visited.add(start);\n        parent.put(start, null);\n        queue.offer(start);\n\n        // (3) BFS 탐색\n        while (!queue.isEmpty()) {\n            String current = queue.poll();\n            log.debug(\"[BFS] 현재 방문 노드: {}\", current);\n\n            if (current.equals(end)) {\n                // 목적지 도착 -> 성공\n                log.debug(\"[BFS] 목적지 '{}'에 도달했습니다.\", end);\n                break;\n            }\n\n            List<String> neighbors = graph.get(current);\n            if (neighbors == null) {\n                continue;\n            }\n            for (String neighbor : neighbors) {\n                if (!visited.contains(neighbor)) {\n                    visited.add(neighbor);\n                    parent.put(neighbor, current);\n                    queue.offer(neighbor);\n                    log.debug(\"[BFS] 새로운 이웃 '{}' 발견 -> queue에 추가\", neighbor);\n                }\n            }\n        }\n\n        // (4) BFS 종료 후, end 노드를 찾지 못했으면 실패 기록\n        if (!parent.containsKey(end)) {\n            log.warn(\"[BFS] '{}'에서 '{}'로 가는 경로를 찾지 못했습니다. (lineNum={})\", start, end, lineNum);\n            logFailedBfs(start, end, lineNum,\n                    \"BFS 종료 후 end 노드를 찾지 못함\",\n                    visited);\n            return Collections.emptyList();\n        }\n\n        // (5) 경로 역추적\n        List<String> path = new ArrayList<>();\n        String node = end;\n        while (node != null) {\n            path.add(node);\n            node = parent.get(node);\n        }\n        Collections.reverse(path);\n\n        log.info(\"[BFS] '{}' -> '{}' (lineNum={}) 경로: {}\", start, end, lineNum, path);\n        return path;\n    }\n\n    /**\n     * BFS 실패 시, JSON 파일(bfs_failures.json)에 기록하는 메서드.\n     * - \"start\", \"end\", \"lineNum\", \"reason\", \"visited\", \"timestamp\" 등을 함께 기록\n     */\n    private void logFailedBfs(String start,\n                              String end,\n                              String lineNum,\n                              String reason,\n                              Set<String> visited) {\n        // ObjectMapper에 Pretty Print(들여쓰기) 설정\n        ObjectMapper mapper = new ObjectMapper().enable(SerializationFeature.INDENT_OUTPUT);\n\n        List<Map<String, Object>> failedList = new ArrayList<>();\n        File file = new File(FAILED_BFS_FILE);\n\n        // 이미 파일이 있으면 기존 내용을 불러옴\n        if (file.exists()) {\n            try {\n                failedList = mapper.readValue(file, new TypeReference<>() {});\n            } catch (IOException e) {\n                log.error(\"Error reading {}: {}\", FAILED_BFS_FILE, e.getMessage());\n            }\n        }\n\n        // 새로운 실패 기록 생성\n        Map<String, Object> record = new HashMap<>();\n        record.put(\"start\", start);\n        record.put(\"end\", end);\n        record.put(\"lineNum\", lineNum);  // 호선 정보\n        record.put(\"timestamp\", LocalDateTime.now().toString());\n        record.put(\"reason\", reason);    // BFS 실패 사유\n        record.put(\"visited\", new ArrayList<>(visited));  // 방문했던 노드 목록\n        record.put(\"message\", \"BFS 경로를 찾지 못했습니다.\");\n\n        failedList.add(record);\n\n        // JSON 파일에 다시 기록\n        try {\n            mapper.writeValue(file, failedList);\n            log.info(\"BFS 실패 기록을 {} 파일에 저장했습니다.\", FAILED_BFS_FILE);\n        } catch (IOException e) {\n            log.error(\"Error writing to {}: {}\", FAILED_BFS_FILE, e.getMessage());\n        }\n    }\n\n}\n",
            "SubwaySyncService.java": "package com.example.subway.service;\n\nimport com.example.subway.domain.TrainInfo;\nimport com.example.subway.repository.TrainInfoRepository;\nimport com.fasterxml.jackson.core.type.TypeReference;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport com.fasterxml.jackson.databind.SerializationFeature;\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.scheduling.annotation.Scheduled;\nimport org.springframework.stereotype.Service;\nimport org.w3c.dom.*;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.URL;\nimport java.net.URLConnection;\nimport java.net.URLEncoder;\nimport java.nio.charset.StandardCharsets;\nimport java.time.LocalDateTime;\nimport java.util.*;\n\n@Slf4j\n@Service\npublic class SubwaySyncService {\n\n    private final TrainInfoRepository trainInfoRepository;\n    private final SubwayGraphService subwayGraphService;\n    private final NotificationService notificationService;\n\n    // 최초 API 키\n    private String apiKey = \"755455636167793236306850475a51\";\n    // API URL 템플릿\n    private static final String SUBWAY_API_URL\n            = \"http://swopenAPI.seoul.go.kr/api/subway/%s/xml/realtimePosition/0/100/%s\";\n    // 로그 기록 파일명\n    private static final String LOG_FILE = \"log.json\";\n\n    public SubwaySyncService(TrainInfoRepository trainInfoRepository,\n                             SubwayGraphService subwayGraphService,\n                             NotificationService notificationService) {\n        this.trainInfoRepository = trainInfoRepository;\n        this.subwayGraphService  = subwayGraphService;\n        this.notificationService = notificationService;\n    }\n\n    /**\n     * 지정된 주기로 각 호선의 열차정보를 동기화합니다.\n     */\n    @Scheduled(fixedDelayString = \"${myapp.schedule.subway-refresh}\")\n    public void syncTrains() {\n        Map<String, String> linesToSync = new LinkedHashMap<>();\n\n        for (int line = 1; line <= 9; line++) {\n            String lineKey = line + \"호선\";\n            linesToSync.put(lineKey, lineKey);\n        }\n        linesToSync.put(\"경강선\", \"경강선\");\n        linesToSync.put(\"경의중앙선\", \"경의선\");  // API는 \"경의중앙선\", DB에는 \"경의선\"으로 저장\n        linesToSync.put(\"경춘선\", \"경춘선\");\n        linesToSync.put(\"공항철도\", \"공항철도\");\n        linesToSync.put(\"서해선\", \"서해선\");\n        linesToSync.put(\"수인분당선\", \"수인분당선\");\n        linesToSync.put(\"신분당선\", \"신분당선\");\n        linesToSync.put(\"신림선\", \"신림선\");\n        linesToSync.put(\"우이신설선\", \"우이신설선\");\n\n        for (Map.Entry<String, String> entry : linesToSync.entrySet()) {\n            String apiLineName = entry.getKey();\n            String dbLineName  = entry.getValue();\n            try {\n                String lineNameEncoded = URLEncoder.encode(apiLineName, \"UTF-8\");\n                syncLine(lineNameEncoded, dbLineName);\n            } catch (Exception e) {\n                log.error(\"Failed to sync line {}: {}\", apiLineName, e.getMessage(), e);\n            }\n        }\n    }\n\n    /**\n     * 특정 호선(lineNameEncoded, lineNum)에 대한 열차정보 동기화 및 DB 정리 로직\n     */\n    private void syncLine(String lineNameEncoded, String lineNum) throws Exception {\n        String apiUrl = String.format(SUBWAY_API_URL, apiKey, lineNameEncoded);\n        log.info(\"[SYNC] {}: API 호출 URL = {}\", lineNum, apiUrl);\n\n        URL url = new URL(apiUrl);\n        URLConnection connection = url.openConnection();\n        String contentType = connection.getContentType();\n        InputStream is = connection.getInputStream();\n\n        if (contentType != null && contentType.contains(\"application/json\")) {\n            String jsonResponse = new String(is.readAllBytes(), StandardCharsets.UTF_8);\n            ObjectMapper mapper = new ObjectMapper();\n            Map<String, Object> responseMap = mapper.readValue(jsonResponse, new TypeReference<Map<String, Object>>() {});\n            if (\"ERROR-337\".equals(responseMap.get(\"code\"))) {\n                if (this.apiKey.equals(\"755455636167793236306850475a51\")) {\n                    this.apiKey = \"51434941476779323635637044786e\";\n                } else if (this.apiKey.equals(\"51434941476779323635637044786e\")) {\n                    this.apiKey = \"4f6b52794467793236325572567469\";\n                }\n                log.warn(\"[ERROR] {}: {} (API 키를 새 값으로 교체함)\", lineNum, jsonResponse);\n                return;\n            }\n            log.info(\"[INFO] {}: JSON 응답 수신: {}\", lineNum, jsonResponse);\n            return;\n        } else {\n            Document doc = DocumentBuilderFactory.newInstance()\n                    .newDocumentBuilder().parse(is);\n            doc.getDocumentElement().normalize();\n\n            NodeList codeNodes = doc.getElementsByTagName(\"code\");\n            if (codeNodes != null && codeNodes.getLength() > 0) {\n                String errorCode = codeNodes.item(0).getTextContent();\n                if (\"ERROR-337\".equals(errorCode)) {\n                    if (this.apiKey.equals(\"755455636167793236306850475a51\")) {\n                        this.apiKey = \"51434941476779323635637044786e\";\n                    } else if (this.apiKey.equals(\"51434941476779323635637044786e\")) {\n                        this.apiKey = \"4f6b52794467793236325572567469\";\n                    }\n                    log.warn(\"[ERROR] {}: 응답 오류 코드 {} 발견 (API 키를 새 값으로 교체함)\", lineNum, errorCode);\n                    return;\n                }\n            }\n\n            NodeList rowList = doc.getElementsByTagName(\"row\");\n            if (rowList.getLength() == 0) {\n                log.info(\"[INFO] {}: 열차 정보가 없습니다.\", lineNum);\n                return;\n            }\n\n            Map<String, List<String>> graph = subwayGraphService.buildGraph(lineNum, false);\n            Set<String> fetchedTrainNos = new HashSet<>();\n\n            for (int i = 0; i < rowList.getLength(); i++) {\n                Node row = rowList.item(i);\n                if (row.getNodeType() != Node.ELEMENT_NODE) {\n                    continue;\n                }\n                Element element = (Element) row;\n\n                String subwayId      = getTagValue(element, \"subwayId\");\n                String statnId       = getTagValue(element, \"statnId\");\n                String trainNo       = getTagValue(element, \"trainNo\");\n                String lastRecptnDt  = getTagValue(element, \"lastRecptnDt\");\n                String recptnDt      = getTagValue(element, \"recptnDt\");\n                String upDown        = getTagValue(element, \"updnLine\");\n                String statnTid      = getTagValue(element, \"statnTid\");\n                String rawCurrStatn  = getTagValue(element, \"statnNm\");\n                String rawEndStatn   = getTagValue(element, \"statnTnm\");\n                String trainSttus    = getTagValue(element, \"trainSttus\");\n                String directAt      = getTagValue(element, \"directAt\");\n                String lstcarAt      = getTagValue(element, \"lstcarAt\");\n\n                String currStatn = removeParentheses(rawCurrStatn);\n                String endStatn  = removeParentheses(rawEndStatn);\n\n                if (trainNo == null || currStatn == null || endStatn == null) {\n                    log.warn(\"Skipping row due to null values: trainNo={}, currStatn={}, endStatn={}\",\n                            trainNo, currStatn, endStatn);\n                    continue;\n                }\n\n                fetchedTrainNos.add(trainNo);\n\n                Optional<TrainInfo> optTrain = trainInfoRepository.findByTrainNo(trainNo);\n                TrainInfo train;\n                if (optTrain.isEmpty()) {\n                    // --- [새 열차 추가] ---\n                    train = new TrainInfo();\n                    train.setSubwayId(subwayId);\n                    train.setStatnId(statnId);\n                    train.setTrainNo(trainNo);\n                    train.setLastRecptnDt(lastRecptnDt);\n                    train.setRecptnDt(recptnDt);\n                    train.setUpDown(upDown);\n                    train.setTrainSttus(trainSttus);\n                    train.setDirectAt(directAt);\n                    train.setLstcarAt(lstcarAt);\n                    train.setCurrentStation(currStatn);\n                    train.setStatnTid(statnTid);\n                    train.setEndStation(endStatn);\n                    train.setLineNum(lineNum);\n\n                    List<String> path = subwayGraphService.bfsPath(graph, currStatn, endStatn);\n                    log.debug(\"[NEW TRAIN] BFS path: {}\", path);\n\n                    train.setStationsJson(toJsonString(path));\n                    train.setUpdateTime(LocalDateTime.now());\n                    trainInfoRepository.save(train);\n\n                    log.info(\"[NEW TRAIN] {} - {} ( {} -> {} )\", trainNo, lineNum, currStatn, endStatn);\n                    logTrainEvent(\"NEW_TRAIN\", train);\n\n                    // 막차 알림 체크 (신규 열차)\n                    notificationService.checkAndSendAlerts(train);\n                } else {\n                    // --- [기존 열차 업데이트] ---\n                    train = optTrain.get();\n                    train.setSubwayId(subwayId);\n                    train.setStatnId(statnId);\n                    train.setTrainNo(trainNo);\n                    train.setLastRecptnDt(lastRecptnDt);\n                    train.setRecptnDt(recptnDt);\n                    train.setUpDown(upDown);\n                    train.setTrainSttus(trainSttus);\n                    train.setDirectAt(directAt);\n                    train.setLstcarAt(lstcarAt);\n                    train.setCurrentStation(currStatn);\n                    train.setStatnTid(statnTid);\n                    train.setEndStation(endStatn);\n                    train.setLineNum(lineNum);\n\n                    List<String> path = fromJsonString(train.getStationsJson());\n                    if (path != null && !path.isEmpty()) {\n                        int currIdx = path.indexOf(currStatn);\n                        if (currIdx > 0) {\n                            for (int idx = 0; idx < currIdx; idx++) {\n                                path.set(idx, null);\n                            }\n                            path.removeIf(Objects::isNull);\n                        }\n                        train.setStationsJson(toJsonString(path));\n                    }\n                    train.setUpdateTime(LocalDateTime.now());\n                    trainInfoRepository.save(train);\n\n                    log.info(\"[UPDATE TRAIN] {} - {} (현재역: {})\", trainNo, lineNum, currStatn);\n                    logTrainEvent(\"UPDATE_TRAIN\", train);\n\n                    // 막차 알림 체크 (업데이트 열차)\n                    notificationService.checkAndSendAlerts(train);\n                }\n            }\n\n            // 삭제 이벤트 처리\n            List<TrainInfo> existingTrains = trainInfoRepository.findByLineNum(lineNum);\n            for (TrainInfo t : existingTrains) {\n                if (!fetchedTrainNos.contains(t.getTrainNo())) {\n                    trainInfoRepository.delete(t);\n                    log.info(\"[DELETE TRAIN] {} - {} (운행 종료)\", t.getTrainNo(), lineNum);\n                    logTrainEvent(\"DELETE_TRAIN\", t);\n                }\n            }\n        }\n    }\n\n    private String getTagValue(Element element, String tag) {\n        NodeList list = element.getElementsByTagName(tag);\n        if (list.getLength() == 0) {\n            return null;\n        }\n        return list.item(0).getTextContent();\n    }\n\n    private String toJsonString(List<String> list) {\n        if (list == null) return \"[]\";\n        return \"[\" + String.join(\",\", list.stream().map(s -> \"\\\"\" + s + \"\\\"\").toList()) + \"]\";\n    }\n\n    private List<String> fromJsonString(String json) {\n        if (json == null || json.isBlank()) {\n            return new ArrayList<>();\n        }\n        String trimmed = json.trim();\n        if (trimmed.startsWith(\"[\") && trimmed.endsWith(\"]\")) {\n            trimmed = trimmed.substring(1, trimmed.length() - 1).trim();\n            if (trimmed.isEmpty()) {\n                return new ArrayList<>();\n            }\n            List<String> result = new ArrayList<>();\n            String[] tokens = trimmed.split(\",\");\n            for (String t : tokens) {\n                String val = t.trim().replaceAll(\"\\\"\", \"\");\n                result.add(val);\n            }\n            return result;\n        }\n        return new ArrayList<>();\n    }\n\n    private String removeParentheses(String input) {\n        if (input == null) {\n            return null;\n        }\n        return input.replaceAll(\"\\\\(.*?\\\\)\", \"\").trim();\n    }\n\n    private void logTrainEvent(String action, TrainInfo train) {\n        ObjectMapper mapper = new ObjectMapper().enable(SerializationFeature.INDENT_OUTPUT);\n        List<Map<String, Object>> logList = new ArrayList<>();\n        File file = new File(LOG_FILE);\n\n        if (file.exists()) {\n            try {\n                logList = mapper.readValue(file, new TypeReference<List<Map<String, Object>>>() {});\n            } catch (IOException e) {\n                log.error(\"log.json 파일 읽기 실패: {}\", e.getMessage(), e);\n            }\n        }\n\n        Map<String, Object> record = new HashMap<>();\n        record.put(\"timestamp\", LocalDateTime.now().toString());\n        record.put(\"action\", action);\n        record.put(\"trainNo\", train.getTrainNo());\n        record.put(\"lineNum\", train.getLineNum());\n        record.put(\"currentStation\", train.getCurrentStation());\n        record.put(\"endStation\", train.getEndStation());\n        record.put(\"upDown\", train.getUpDown());\n        record.put(\"express\", train.getDirectAt());\n        logList.add(record);\n\n        try {\n            mapper.writeValue(file, logList);\n            log.info(\"log.json 파일에 {} 이벤트 기록 완료: {}\", action, record);\n        } catch (IOException e) {\n            log.error(\"log.json 파일 쓰기 실패: {}\", e.getMessage(), e);\n        }\n    }\n}\n",
            "UserService.java": "package com.example.subway.service;\n\nimport com.example.subway.domain.User;\nimport com.example.subway.dto.UserRegistrationRequest;\nimport com.example.subway.dto.UserLoginRequest;\nimport com.example.subway.repository.UserRepository;\nimport com.example.subway.repository.SubwayStationRepository;\nimport org.springframework.security.crypto.password.PasswordEncoder;\nimport org.springframework.stereotype.Service;\n\nimport java.util.Optional;\n\n@Service\npublic class UserService {\n    private final UserRepository userRepository;\n    private final SubwayStationRepository subwayStationRepository;\n    private final PasswordEncoder passwordEncoder;\n\n    public UserService(UserRepository userRepository,\n                       SubwayStationRepository subwayStationRepository,\n                       PasswordEncoder passwordEncoder) {\n        this.userRepository = userRepository;\n        this.subwayStationRepository = subwayStationRepository;\n        this.passwordEncoder = passwordEncoder;\n    }\n\n    // 회원가입 처리: 입력받은 근무역이 subway_stations 테이블에 존재하는지 확인\n    public User registerUser(UserRegistrationRequest request) {\n        // existsByStationname() 메서드를 사용하여 역 존재 여부를 확인\n        if (!subwayStationRepository.existsByStationname(request.getWorkStation())) {\n            throw new RuntimeException(\"입력하신 근무역이 존재하지 않습니다.\");\n        }\n        if (userRepository.findByUsername(request.getUsername()).isPresent()) {\n            throw new RuntimeException(\"Username already exists\");\n        }\n        User user = new User();\n        user.setUsername(request.getUsername());\n        // 비밀번호는 암호화하여 저장\n        user.setPassword(passwordEncoder.encode(request.getPassword()));\n        user.setWorkStation(request.getWorkStation());\n        user.setAlertThreshold(request.getAlertThreshold());\n        return userRepository.save(user);\n    }\n\n    // 로그인 인증 (아이디/비밀번호 확인)\n    public Optional<User> authenticate(UserLoginRequest request) {\n        Optional<User> userOpt = userRepository.findByUsername(request.getUsername());\n        if (userOpt.isPresent() && passwordEncoder.matches(request.getPassword(), userOpt.get().getPassword())) {\n            return userOpt;\n        }\n        return Optional.empty();\n    }\n\n    // 프로필(근무역, 알림 정거장 수) 업데이트: 변경 시에도 근무역의 존재 여부를 검사\n    public User updateUserProfile(Long userId, String workStation, int alertThreshold) {\n        if (!subwayStationRepository.existsByStationname(workStation)) {\n            throw new RuntimeException(\"입력하신 근무역이 존재하지 않습니다.\");\n        }\n        User user = userRepository.findById(userId)\n                .orElseThrow(() -> new RuntimeException(\"User not found\"));\n        user.setWorkStation(workStation);\n        user.setAlertThreshold(alertThreshold);\n        return userRepository.save(user);\n    }\n}\n"
        }
    }
}