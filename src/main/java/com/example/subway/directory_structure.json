{
    "__files__": {
        "codes.py": null,
        "directory_structure.json": null,
        "SubwayApplication.java": "package com.example.subway;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.scheduling.annotation.EnableScheduling;\n\n@SpringBootApplication\n@EnableScheduling  // 스케줄링 기능\npublic class SubwayApplication {\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(SubwayApplication.class, args);\n\t}\n}\n"
    },
    "config": {},
    "controller": {
        "__files__": {
            "StationController.java": "package com.example.subway.controller;\n\nimport com.example.subway.domain.TrainInfo;\nimport com.example.subway.dto.StationTrainResponse;\nimport com.example.subway.repository.TrainInfoRepository;\nimport com.fasterxml.jackson.core.type.TypeReference;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.PathVariable;\nimport org.springframework.web.bind.annotation.RestController;\n\nimport java.io.IOException;\nimport java.util.*;\n\n@Slf4j\n@RestController\npublic class StationController {\n\n    private final TrainInfoRepository trainInfoRepository;\n    private final ObjectMapper objectMapper = new ObjectMapper();\n\n    public StationController(TrainInfoRepository trainInfoRepository) {\n        this.trainInfoRepository = trainInfoRepository;\n    }\n\n    @GetMapping(\"/api/station/{stationName}\")\n    public List<StationTrainResponse> getTrainsPassingStation(\n            @PathVariable(\"stationName\") String stationName) {\n\n        List<TrainInfo> allTrains = trainInfoRepository.findAll();\n        List<StationTrainResponse> result = new ArrayList<>();\n\n        for (TrainInfo train : allTrains) {\n            // Parse the JSON stations array into a List<String>\n            List<String> path = convertJsonToList(train.getStationsJson());\n            if (path == null) {\n                // Parsing error or empty JSON\n                continue;\n            }\n\n            // 1) Find the index of the requested station\n            int stationIndex = path.indexOf(stationName);\n            if (stationIndex == -1) {\n                // This train does not pass through stationName\n                continue;\n            }\n\n            // 2) Find the index of the train’s current station\n            int currIndex = path.indexOf(train.getCurrentStation());\n            if (currIndex == -1) {\n                // Edge case: currentStation not found in stationsJson\n                continue;\n            }\n\n            // 3) Calculate remaining stations\n            int remainingStations = stationIndex - currIndex;\n            if (remainingStations < 0) {\n                // Already passed the station\n                continue;\n            }\n\n            // 4) Build the response DTO\n            StationTrainResponse dto = new StationTrainResponse(\n                    train.getTrainNo(),\n                    train.getUpDown(),\n                    train.getExpressYn(),\n                    train.getCurrentStation(),\n                    train.getEndStation(),\n                    remainingStations\n            );\n            result.add(dto);\n        }\n\n        // Sort by ascending “remainingStations”\n        result.sort(Comparator.comparingInt(StationTrainResponse::getRemainingStations));\n\n        return result;\n    }\n\n    /**\n     * Helper method to parse a JSON string representing an array of stations\n     * into a List<String> using Jackson.\n     */\n    private List<String> convertJsonToList(String json) {\n        if (json == null || json.isEmpty()) {\n            return null;\n        }\n        try {\n            return objectMapper.readValue(json, new TypeReference<List<String>>() {});\n        } catch (IOException e) {\n            log.error(\"Failed to parse JSON string: {}\", json, e);\n            return null;\n        }\n    }\n}\n"
        }
    },
    "domain": {
        "__files__": {
            "SubwayData.java": "package com.example.subway.domain;\n\nimport jakarta.persistence.*;\nimport lombok.Getter;\nimport lombok.Setter;\n\n@Entity\n@Getter\n@Setter\npublic class SubwayData {\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n\n    private String linenum;\n\n    private String frontStationname;\n    private String frontOutercode;\n\n    private String backStationname;\n    private String backOutercode;\n\n}\n",
            "SubwayStations.java": "package com.example.subway.domain;\n\nimport jakarta.persistence.Entity;\nimport jakarta.persistence.Id;\nimport lombok.Getter;\nimport lombok.Setter;\n\n@Entity\n@Getter\n@Setter\npublic class SubwayStations {\n\n    @Id\n    private String stationcode;\n\n    private String stationname;\n    private String stationeng;\n    private String linenum;\n    private String outercode;\n}\n",
            "TrainInfo.java": "package com.example.subway.domain;\n\nimport jakarta.persistence.*;\nimport lombok.Getter;\nimport lombok.Setter;\nimport java.time.LocalDateTime;\n\n@Entity\n@Getter\n@Setter\npublic class TrainInfo {\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n\n    private String trainNo;        // 열차번호\n    private String upDown;         // 상하선 정보\n    private String expressYn;      // 막차 여부\n    private String currentStation; // 현재역\n    private String endStation;     // 종착역\n\n    // ------------------- [새로 추가된 부분] -------------------\n    private String lineNum;        // 소속된 호선\n    // -------------------------------------------------------\n\n    @Lob\n    private String stationsJson;   // 열차가 지나갈 역 목록 (JSON)\n\n    private LocalDateTime updateTime; // 마지막 갱신 시간\n}\n"
        }
    },
    "dto": {
        "__files__": {
            "StationTrainResponse.java": "package com.example.subway.dto;\n\nimport lombok.AllArgsConstructor;\nimport lombok.Getter;\n\n@Getter\n@AllArgsConstructor\npublic class StationTrainResponse {\n    private String trainNo;\n    private String upDown;\n    private String expressYn;\n    private String currentStation;\n    private String endStation;\n    private int remainingStations; // 남은 정거장 수\n}\n"
        }
    },
    "repository": {
        "__files__": {
            "SubwayDataRepository.java": "package com.example.subway.repository;\n\nimport com.example.subway.domain.SubwayData;\nimport org.springframework.data.jpa.repository.JpaRepository;\n\npublic interface SubwayDataRepository extends JpaRepository<SubwayData, Long> {\n    // line별로 가져오기\n    // List<SubwayData> findByLinenum(String linenum);\n}\n",
            "SubwayStationRepository.java": "package com.example.subway.repository;\n\nimport com.example.subway.domain.SubwayStations;\nimport org.springframework.data.jpa.repository.JpaRepository;\n\npublic interface SubwayStationRepository extends JpaRepository<SubwayStations, String> {\n    // stationcode(String) 이 PK\n}\n",
            "TrainInfoRepository.java": "package com.example.subway.repository;\n\nimport com.example.subway.domain.TrainInfo;\nimport org.springframework.data.jpa.repository.JpaRepository;\n\nimport java.util.Optional;\n\npublic interface TrainInfoRepository extends JpaRepository<TrainInfo, Long> {\n    // 열차번호로 조회\n    Optional<TrainInfo> findByTrainNo(String trainNo);\n}\n"
        }
    },
    "service": {
        "__files__": {
            "SubwayGraphService.java": "package com.example.subway.service;\n\nimport com.example.subway.domain.SubwayData;\nimport com.example.subway.repository.SubwayDataRepository;\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.stereotype.Service;\n\nimport java.util.*;\n\n@Slf4j\n@Service\npublic class SubwayGraphService {\n\n    private final SubwayDataRepository subwayDataRepository;\n\n    public SubwayGraphService(SubwayDataRepository subwayDataRepository) {\n        this.subwayDataRepository = subwayDataRepository;\n    }\n\n    // 특정 호선에 대해 인접 리스트 형태의 그래프를 구성\n    public Map<String, List<String>> buildGraph(String lineNum) {\n        // 1) DB에서 전체 SubwayData 로딩\n        List<SubwayData> dataList = subwayDataRepository.findAll();\n\n        // 2) 로드된 모든 레코드 로그 출력 (디버그용)\n        log.info(\"===== [SubwayData 테이블 전체 조회 결과] =====\");\n        for (SubwayData data : dataList) {\n            log.info(\"Row => id={}, linenum={}, frontStationname={}, frontOutercode={}, backStationname={}, backOutercode={}\",\n                    data.getId(),\n                    data.getLinenum(),\n                    data.getFrontStationname(),\n                    data.getFrontOutercode(),\n                    data.getBackStationname(),\n                    data.getBackOutercode()\n            );\n        }\n        log.info(\"===== [총 {}개 레코드 조회 완료] =====\", dataList.size());\n\n        // 3) lineNum에 해당하는 레코드만 골라서 그래프 구성\n        Map<String, List<String>> graph = new HashMap<>();\n        for (SubwayData data : dataList) {\n            // lineNum 일치하는 것만 처리\n            if (!data.getLinenum().equals(lineNum)) {\n                continue;\n            }\n\n            String front = data.getFrontStationname();\n            String back  = data.getBackStationname();\n\n            // 인접 리스트에 추가\n            graph.computeIfAbsent(front, k -> new ArrayList<>()).add(back);\n            graph.computeIfAbsent(back, k -> new ArrayList<>()).add(front);\n        }\n\n        return graph;\n    }\n\n    // BFS로 start~end 경로 찾기\n    public List<String> bfsPath(Map<String, List<String>> graph, String start, String end) {\n        log.info(\"----- BFS START: from '{}' to '{}' -----\", start, end);\n\n        // 그래프에 start나 end가 없으면 빈 리스트 반환\n        if (!graph.containsKey(start) || !graph.containsKey(end)) {\n            log.warn(\"[BFS] start='{}' 혹은 end='{}'가 graph에 존재하지 않습니다. 빈 경로 반환.\", start, end);\n            return Collections.emptyList();\n        }\n\n        Set<String> visited = new HashSet<>();\n        Map<String, String> parent = new HashMap<>();\n        Queue<String> queue = new LinkedList<>();\n\n        visited.add(start);\n        parent.put(start, null);\n        queue.offer(start);\n\n        while (!queue.isEmpty()) {\n            String current = queue.poll();\n            log.debug(\"[BFS] 현재 방문 노드: {}\", current);\n\n            // end 지점에 도달\n            if (current.equals(end)) {\n                log.debug(\"[BFS] 목적지 '{}'에 도달했습니다.\", end);\n                break;\n            }\n\n            List<String> neighbors = graph.get(current);\n            if (neighbors == null) {\n                continue;\n            }\n            for (String neighbor : neighbors) {\n                if (!visited.contains(neighbor)) {\n                    visited.add(neighbor);\n                    parent.put(neighbor, current);\n                    queue.offer(neighbor);\n                    log.debug(\"[BFS] 새로운 이웃 '{}' 발견 -> queue에 추가\", neighbor);\n                }\n            }\n        }\n\n        // end 노드가 parent에 없으면 경로가 없다는 뜻\n        if (!parent.containsKey(end)) {\n            log.warn(\"[BFS] '{}'로 가는 경로를 찾지 못했습니다. 빈 경로 반환.\", end);\n            return Collections.emptyList();\n        }\n\n        // parent 맵을 역추적\n        List<String> path = new ArrayList<>();\n        String node = end;\n        while (node != null) {\n            path.add(node);\n            node = parent.get(node);\n        }\n        Collections.reverse(path);\n\n        log.info(\"[BFS] '{}' -> '{}' 경로: {}\", start, end, path);\n        return path;\n    }\n}\n",
            "SubwaySyncService.java": "package com.example.subway.service;\n\nimport com.example.subway.domain.TrainInfo;\nimport com.example.subway.repository.TrainInfoRepository;\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.scheduling.annotation.Scheduled;\nimport org.springframework.stereotype.Service;\nimport org.w3c.dom.*;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport java.net.URL;\nimport java.net.URLEncoder;\nimport java.time.LocalDateTime;\nimport java.util.*;\n\n@Slf4j\n@Service\npublic class SubwaySyncService {\n\n    private final TrainInfoRepository trainInfoRepository;\n    private final SubwayGraphService subwayGraphService;\n\n    // 예시 API 키 (테스트용)\n    private static final String API_KEY = \"755455636167793236306850475a51\";\n    // swopenAPI: (API_KEY, 노선명) 순서로 URL 구성\n    private static final String SUBWAY_API_URL\n            = \"http://swopenAPI.seoul.go.kr/api/subway/%s/xml/realtimePosition/0/100/%s\";\n\n    public SubwaySyncService(TrainInfoRepository trainInfoRepository,\n                             SubwayGraphService subwayGraphService) {\n        this.trainInfoRepository = trainInfoRepository;\n        this.subwayGraphService  = subwayGraphService;\n    }\n\n    /**\n     * 지정된 주기로 1~2호선 열차정보를 동기화\n     * (원래는 1~9호선을 돌리는 로직)\n     */\n    @Scheduled(fixedDelayString = \"${myapp.schedule.subway-refresh}\")\n    public void syncTrains() {\n        for (int line = 1; line <= 2; line++) {\n            String lineNum = line + \"호선\";\n            try {\n                // URL 인코딩\n                String lineNameEncoded = URLEncoder.encode(lineNum, \"UTF-8\");\n                syncLine(lineNameEncoded, lineNum);\n            } catch (Exception e) {\n                log.error(\"Failed to sync line {}: {}\", lineNum, e.getMessage(), e);\n            }\n        }\n    }\n\n    /**\n     * 특정 호선(lineNameEncoded, lineNum)에 대한 열차정보 동기화 로직\n     */\n    private void syncLine(String lineNameEncoded, String lineNum) throws Exception {\n        // 1) API 호출\n        String apiUrl = String.format(SUBWAY_API_URL, API_KEY, lineNameEncoded);\n        Document doc = DocumentBuilderFactory.newInstance()\n                .newDocumentBuilder()\n                .parse(new URL(apiUrl).openStream());\n        doc.getDocumentElement().normalize();\n\n        NodeList rowList = doc.getElementsByTagName(\"row\");\n        if (rowList.getLength() == 0) {\n            log.info(\"[INFO] {}: 열차 정보가 없습니다.\", lineNum);\n            return;\n        }\n\n        // 2) 이 노선(lineNum)에 대한 그래프 미리 구성\n        Map<String, List<String>> graph = subwayGraphService.buildGraph(lineNum);\n\n        // 3) row 순회\n        for (int i = 0; i < rowList.getLength(); i++) {\n            Node row = rowList.item(i);\n            if (row.getNodeType() != Node.ELEMENT_NODE) {\n                continue;\n            }\n            Element element = (Element) row;\n\n            // 열차번호\n            String trainNo  = getTagValue(element, \"trainNo\");\n            // 상/하행 정보(updnLine)\n            String upDown   = getTagValue(element, \"updnLine\");\n            // (예시) 막차 여부\n            String expressYn= getTagValue(element, \"expressyn\");\n            // 현재역\n            String currStatn= getTagValue(element, \"statnNm\");\n            // 종착역\n            String endStatn = getTagValue(element, \"statnTnm\");\n\n            if (trainNo == null || currStatn == null || endStatn == null) {\n                // 최소한의 정보가 없으면 스킵\n                log.warn(\"Skipping row due to null values: trainNo={}, currStatn={}, endStatn={}\",\n                        trainNo, currStatn, endStatn);\n                continue;\n            }\n\n            // 기존 열차 존재 여부 확인\n            Optional<TrainInfo> optTrain = trainInfoRepository.findByTrainNo(trainNo);\n            TrainInfo train;\n            if (optTrain.isEmpty()) {\n                // ------------ [새 열차] ------------\n                train = new TrainInfo();\n                train.setTrainNo(trainNo);\n                train.setUpDown(upDown);\n                train.setExpressYn(expressYn);\n                train.setCurrentStation(currStatn);\n                train.setEndStation(endStatn);\n\n                // [추가] 호선 저장\n                train.setLineNum(lineNum);\n\n                // BFS 수행 (현재역->종착역)\n                List<String> path = subwayGraphService.bfsPath(graph, currStatn, endStatn);\n                log.debug(\"[NEW TRAIN] BFS path: {}\", path);\n\n                // path를 JSON 문자열로 변환해 저장\n                train.setStationsJson(toJsonString(path));\n                train.setUpdateTime(LocalDateTime.now());\n                trainInfoRepository.save(train);\n\n                log.info(\"[NEW TRAIN] {} - {} ( {} -> {} )\", trainNo, lineNum, currStatn, endStatn);\n\n            } else {\n                // ------------ [기존 열차 업데이트] ------------\n                train = optTrain.get();\n                train.setUpDown(upDown);\n                train.setExpressYn(expressYn);\n                train.setCurrentStation(currStatn);\n                train.setEndStation(endStatn);\n\n                // [추가] 호선 업데이트\n                train.setLineNum(lineNum);\n\n                // 현재 stationsJson을 파싱 -> 지나간 역 제거\n                List<String> path = fromJsonString(train.getStationsJson());\n                if (path != null && !path.isEmpty()) {\n                    // 예: \"지나간 역 삭제\" 로직\n                    int currIdx = path.indexOf(currStatn);\n                    if (currIdx > 0) {\n                        // 0부터 (currIdx-1)까지 삭제\n                        for (int idx = 0; idx < currIdx; idx++) {\n                            path.set(idx, null);\n                        }\n                        path.removeIf(Objects::isNull);\n                    }\n                    // 업데이트 된 경로 다시 JSON으로 저장\n                    train.setStationsJson(toJsonString(path));\n                }\n\n                train.setUpdateTime(LocalDateTime.now());\n                trainInfoRepository.save(train);\n\n                log.info(\"[UPDATE TRAIN] {} - {} (현재역: {})\", trainNo, lineNum, currStatn);\n            }\n        }\n    }\n\n    /**\n     * XML Element에서 tag에 해당하는 텍스트 값을 뽑아내는 헬퍼 메서드\n     */\n    private String getTagValue(Element element, String tag) {\n        NodeList list = element.getElementsByTagName(tag);\n        if (list.getLength() == 0) {\n            return null;\n        }\n        return list.item(0).getTextContent();\n    }\n\n    /**\n     * List<String> -> JSON 문자열 변환 (간단 버전)\n     * 예) [\"서울역\",\"시청역\",\"종각역\"]\n     */\n    private String toJsonString(List<String> list) {\n        if (list == null) return \"[]\";\n        return \"[\" + String.join(\",\",\n                list.stream().map(s -> \"\\\"\" + s + \"\\\"\").toList()\n        ) + \"]\";\n    }\n\n    /**\n     * JSON 문자열 -> List<String> 변환 (간단 버전)\n     * 실제로는 Jackson 등을 사용하는 것이 안전/유연\n     */\n    private List<String> fromJsonString(String json) {\n        if (json == null || json.isBlank()) {\n            return new ArrayList<>();\n        }\n        String trimmed = json.trim();\n        if (trimmed.startsWith(\"[\") && trimmed.endsWith(\"]\")) {\n            trimmed = trimmed.substring(1, trimmed.length() - 1).trim();\n            if (trimmed.isEmpty()) {\n                return new ArrayList<>();\n            }\n            // 쉼표(,)로 split 후 양쪽의 \" 제거\n            List<String> result = new ArrayList<>();\n            String[] tokens = trimmed.split(\",\");\n            for (String t : tokens) {\n                String val = t.trim().replaceAll(\"\\\"\", \"\");\n                result.add(val);\n            }\n            return result;\n        }\n        return new ArrayList<>();\n    }\n}\n"
        }
    }
}