{
    "__files__": {
        "codes.py": null,
        "directory_structure.json": null,
        "SubwayApplication.java": "package com.example.subway;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.scheduling.annotation.EnableScheduling;\n\n@SpringBootApplication\n@EnableScheduling  // 스케줄링 기능\npublic class SubwayApplication {\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(SubwayApplication.class, args);\n\t}\n}\n"
    },
    "config": {
        "__files__": {
            "DatabaseInitializer.java": "package com.example.subway.config;\n\nimport com.example.subway.repository.TrainInfoRepository;\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.stereotype.Component;\nimport jakarta.annotation.PostConstruct;\n\n/**\n * 애플리케이션이 시작될 때 train_info 테이블을 초기화(전량 삭제)하는 예시\n */\n@Slf4j\n@Component\npublic class DatabaseInitializer {\n\n    private final TrainInfoRepository trainInfoRepository;\n\n    public DatabaseInitializer(TrainInfoRepository trainInfoRepository) {\n        this.trainInfoRepository = trainInfoRepository;\n    }\n\n    @PostConstruct\n    public void initDatabase() {\n        // (1) 기존 train_info 내용 모두 삭제\n        trainInfoRepository.deleteAll();\n\n        // (2) 필요한 경우, 초기 데이터 Insert 가능\n        // ex) trainInfoRepository.save(...);\n\n        log.info(\"[INIT] train_info 테이블을 초기화(deleteAll)했습니다.\");\n    }\n}\n"
        }
    },
    "controller": {
        "__files__": {
            "StationController.java": "package com.example.subway.controller;\n\nimport com.example.subway.domain.TrainInfo;\nimport com.example.subway.dto.StationTrainResponse;\nimport com.example.subway.repository.TrainInfoRepository;\nimport com.fasterxml.jackson.core.type.TypeReference;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.PathVariable;\nimport org.springframework.web.bind.annotation.RestController;\n\nimport java.io.IOException;\nimport java.util.*;\n\n@Slf4j\n@RestController\npublic class StationController {\n\n    private final TrainInfoRepository trainInfoRepository;\n    private final ObjectMapper objectMapper = new ObjectMapper();\n\n    public StationController(TrainInfoRepository trainInfoRepository) {\n        this.trainInfoRepository = trainInfoRepository;\n    }\n\n    @GetMapping(\"/api/station/{stationName}\")\n    public List<StationTrainResponse> getTrainsPassingStation(\n            @PathVariable(\"stationName\") String stationName) {\n\n        List<TrainInfo> allTrains = trainInfoRepository.findAll();\n        List<StationTrainResponse> result = new ArrayList<>();\n\n        for (TrainInfo train : allTrains) {\n            // Parse the JSON stations array into a List<String>\n            List<String> path = convertJsonToList(train.getStationsJson());\n            if (path == null) {\n                // Parsing error or empty JSON\n                continue;\n            }\n\n            // 1) Find the index of the requested station\n            int stationIndex = path.indexOf(stationName);\n            if (stationIndex == -1) {\n                // This train does not pass through stationName\n                continue;\n            }\n\n            // 2) Find the index of the train’s current station\n            int currIndex = path.indexOf(train.getCurrentStation());\n            if (currIndex == -1) {\n                // Edge case: currentStation not found in stationsJson\n                continue;\n            }\n\n            // 3) Calculate remaining stations\n            int remainingStations = stationIndex - currIndex;\n            if (remainingStations < 0) {\n                // Already passed the station\n                continue;\n            }\n\n            // 4) Build the response DTO\n            StationTrainResponse dto = new StationTrainResponse(\n                    train.getTrainNo(),\n                    train.getUpDown(),\n                    train.getLstcarAt(),\n                    train.getCurrentStation(),\n                    train.getEndStation(),\n                    remainingStations\n            );\n            result.add(dto);\n        }\n\n        // Sort by ascending “remainingStations”\n        result.sort(Comparator.comparingInt(StationTrainResponse::getRemainingStations));\n\n        return result;\n    }\n\n    /**\n     * Helper method to parse a JSON string representing an array of stations\n     * into a List<String> using Jackson.\n     */\n    private List<String> convertJsonToList(String json) {\n        if (json == null || json.isEmpty()) {\n            return null;\n        }\n        try {\n            return objectMapper.readValue(json, new TypeReference<List<String>>() {});\n        } catch (IOException e) {\n            log.error(\"Failed to parse JSON string: {}\", json, e);\n            return null;\n        }\n    }\n}\n"
        }
    },
    "domain": {
        "__files__": {
            "SubwayData.java": "package com.example.subway.domain;\n\nimport jakarta.persistence.*;\nimport lombok.Getter;\nimport lombok.Setter;\n\n@Entity\n@Getter\n@Setter\npublic class SubwayData {\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id; // 고유 id\n\n    private String linenum; // 몇호선에 존재하는 관계인지\n\n    /* 연결관계는 앞 > 뒤로 연결됨, 앞 > 뒤의 연결관계 방향에 따라 upDown 상행 하행을 저장 */\n    private String frontStationname; // 앞 역 이름\n    private String frontOutercode;  // 앞 역 외부코드\n\n    private String backStationname;  // 뒷 역 이름\n    private String backOutercode;    // 뒷 역 외부코드\n\n    private String upDown; // 상행 하행 저장정보. 상행(내선):0, 하행(외선):1\n\n    // 급행 노선 여부: \"Y\"이면 급행, \"N\"이면 일반 노선\n    private String expressYn;\n}\n",
            "SubwayStations.java": "package com.example.subway.domain;\n\nimport jakarta.persistence.Entity;\nimport jakarta.persistence.Id;\nimport lombok.Getter;\nimport lombok.Setter;\n\n@Entity\n@Getter\n@Setter\npublic class SubwayStations {\n\n    @Id\n    private String stationcode; //역 코드 id\n\n    private String stationname; //역 이름\n    private String stationeng; //역 이름 영문\n    private String linenum; //역에 지나는 호선\n    private String outercode; //역의 외부코드\n    /*역에 지나는 호선이 여러개인 경우, 지나는 호선 개수만큼 하나의 역에 여러개의 외부코드가 있음.\n     현재 저장된 방식은 하나의 역마다 여러개의 외부코드가 있을 경우 여러 행에 저장됨.\n     예시)\n     0150\t서울역\tSeoul Station\t1호선\t133\n     0426\t서울역\tSeoul Station\t4호선\t426\n     1251\t서울역\tSeoul Station\t경의선\tP313\n     4201\t서울역\tSeoul Station\t공항철도\tA01\n     */\n}\n",
            "TrainInfo.java": "package com.example.subway.domain;\n\nimport jakarta.persistence.*;\nimport lombok.Getter;\nimport lombok.Setter;\nimport java.time.LocalDateTime;\n\n@Entity\n@Getter\n@Setter\npublic class TrainInfo {\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n\n    // API에서 받아오는 필드들\n    private String subwayId;     // 지하철호선ID (예: 1001, 1063 등)\n    private String statnId;      // 지하철역ID (현재역 ID)\n    private String trainNo;      // 열차번호\n    private String lastRecptnDt; // 최종수신날짜\n    private String recptnDt;     // 최종수신시간\n    private String upDown;       // 상하행 정보 (0: 상행/내선, 1: 하행/외선)\n    private String trainSttus;   // 열차상태구분 (0:진입, 1:도착, 2:출발, 3:전역출발)\n    private String directAt;     // 급행여부 (1:급행, 0:아님, 7:특급)\n    private String lstcarAt;     // 막차여부 (1:막차, 0:아님)\n\n    // API에서 받아온 현재역, 종착역명에서 소괄호 제거 후 저장\n    private String currentStation; // 현재역 (statnNm, 소괄호 제거)\n    private String statnTid;       // 종착지하철역ID\n    private String endStation;     // 종착역 (statnTnm, 소괄호 제거)\n\n    // 추가 정보: DB에서 사용하는 노선명 (예: \"1호선\", \"경의선\" 등)\n    private String lineNum;\n\n    @Lob\n    private String stationsJson;   // 열차가 지나갈 역 목록 (JSON)\n\n    private LocalDateTime updateTime; // 마지막 갱신 시간\n}\n"
        }
    },
    "dto": {
        "__files__": {
            "StationTrainResponse.java": "package com.example.subway.dto;\n\nimport lombok.AllArgsConstructor;\nimport lombok.Getter;\n\n@Getter\n@AllArgsConstructor\npublic class StationTrainResponse {\n    private String trainNo;\n    private String upDown;\n    private String expressYn;\n    private String currentStation;\n    private String endStation;\n    private int remainingStations; // 남은 정거장 수\n}\n"
        }
    },
    "repository": {
        "__files__": {
            "SubwayDataRepository.java": "package com.example.subway.repository;\n\nimport com.example.subway.domain.SubwayData;\nimport org.springframework.data.jpa.repository.JpaRepository;\n\npublic interface SubwayDataRepository extends JpaRepository<SubwayData, Long> {\n    // line별로 가져오기\n    // List<SubwayData> findByLinenum(String linenum);\n}\n",
            "SubwayStationRepository.java": "package com.example.subway.repository;\n\nimport com.example.subway.domain.SubwayStations;\nimport org.springframework.data.jpa.repository.JpaRepository;\n\npublic interface SubwayStationRepository extends JpaRepository<SubwayStations, String> {\n    // stationcode(String) 이 PK\n}\n",
            "TrainInfoRepository.java": "// TrainInfoRepository.java\npackage com.example.subway.repository;\n\nimport com.example.subway.domain.TrainInfo;\nimport org.springframework.data.jpa.repository.JpaRepository;\n\nimport java.util.List;\nimport java.util.Optional;\n\npublic interface TrainInfoRepository extends JpaRepository<TrainInfo, Long> {\n    Optional<TrainInfo> findByTrainNo(String trainNo);\n\n    // 추가: lineNum 기준으로 조회\n    List<TrainInfo> findByLineNum(String lineNum);\n}\n"
        }
    },
    "service": {
        "__files__": {
            "SubwayGraphService.java": "package com.example.subway.service;\n\nimport com.example.subway.domain.SubwayData;\nimport com.example.subway.repository.SubwayDataRepository;\nimport com.fasterxml.jackson.core.type.TypeReference;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport com.fasterxml.jackson.databind.SerializationFeature;\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.stereotype.Service;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.time.LocalDateTime;\nimport java.util.*;\n\n@Slf4j\n@Service\npublic class SubwayGraphService {\n\n    private final SubwayDataRepository subwayDataRepository;\n\n    // BFS 실패 건을 기록할 JSON 파일 경로\n    private static final String FAILED_BFS_FILE = \"bfs_failures.json\";\n\n    public SubwayGraphService(SubwayDataRepository subwayDataRepository) {\n        this.subwayDataRepository = subwayDataRepository;\n    }\n\n    /**\n     * 특정 호선(lineNum)에 대응하는 인접 그래프를 생성 (일반 노선 기준).\n     */\n    public Map<String, List<String>> buildGraph(String lineNum) {\n        return buildGraph(lineNum, false);\n    }\n\n    /**\n     * 특정 호선(lineNum)에 대해, expressOnly 플래그에 따라\n     * 일반 노선 / 급행 노선만 필터링하여 인접 그래프를 생성.\n     */\n    public Map<String, List<String>> buildGraph(String lineNum, boolean expressOnly) {\n        List<SubwayData> dataList = subwayDataRepository.findAll();\n\n        Map<String, List<String>> graph = new HashMap<>();\n        for (SubwayData data : dataList) {\n            // 1) 호선 필터\n            if (!data.getLinenum().equals(lineNum)) {\n                continue;\n            }\n            // 2) 급행 여부 필터\n            if (expressOnly && !\"Y\".equalsIgnoreCase(data.getExpressYn())) {\n                continue;\n            }\n            if (!expressOnly && \"Y\".equalsIgnoreCase(data.getExpressYn())) {\n                continue;\n            }\n\n            String front = data.getFrontStationname();\n            String back  = data.getBackStationname();\n\n            // 양방향 그래프 구성\n            graph.computeIfAbsent(front, k -> new ArrayList<>()).add(back);\n            graph.computeIfAbsent(back, k -> new ArrayList<>()).add(front);\n        }\n        return graph;\n    }\n\n    /**\n     * BFS로 start에서 end로 가는 경로를 탐색 (호선 정보를 알 수 없을 때 오버로드).\n     * 기존 코드를 깨지 않기 위해 남겨둔 메서드입니다.\n     */\n    public List<String> bfsPath(Map<String, List<String>> graph, String start, String end) {\n        // 호선 정보를 알 수 없으면 임시로 \"UNKNOWN_LINE\" 사용\n        return bfsPath(graph, start, end, \"UNKNOWN_LINE\");\n    }\n\n    /**\n     * BFS로 start에서 end로 가는 경로를 탐색 (호선(lineNum) 포함).\n     * 실패 시 \"왜 못찾았는지(reason)\" + \"어디까지 탐색했는지(visited)\" + \"호선(lineNum)\"을\n     * JSON 파일(Pretty Print)로 기록합니다.\n     */\n    public List<String> bfsPath(Map<String, List<String>> graph, String start, String end, String lineNum) {\n        log.info(\"----- BFS START [lineNum={}] from '{}' to '{}' -----\", lineNum, start, end);\n\n        // (1) start/end 노드가 그래프에 없는 경우 -> 실패 기록\n        if (!graph.containsKey(start) || !graph.containsKey(end)) {\n            log.warn(\"[BFS] start='{}' 혹은 end='{}'가 lineNum='{}' 그래프에 없습니다.\", start, end, lineNum);\n            logFailedBfs(start, end, lineNum,\n                    \"Start 혹은 End 노드가 그래프에 존재하지 않음\",\n                    Collections.emptySet());\n            return Collections.emptyList();\n        }\n\n        // (2) BFS 준비\n        Set<String> visited = new HashSet<>();\n        Map<String, String> parent = new HashMap<>();\n        Queue<String> queue = new LinkedList<>();\n\n        visited.add(start);\n        parent.put(start, null);\n        queue.offer(start);\n\n        // (3) BFS 탐색\n        while (!queue.isEmpty()) {\n            String current = queue.poll();\n            log.debug(\"[BFS] 현재 방문 노드: {}\", current);\n\n            if (current.equals(end)) {\n                // 목적지 도착 -> 성공\n                log.debug(\"[BFS] 목적지 '{}'에 도달했습니다.\", end);\n                break;\n            }\n\n            List<String> neighbors = graph.get(current);\n            if (neighbors == null) {\n                continue;\n            }\n            for (String neighbor : neighbors) {\n                if (!visited.contains(neighbor)) {\n                    visited.add(neighbor);\n                    parent.put(neighbor, current);\n                    queue.offer(neighbor);\n                    log.debug(\"[BFS] 새로운 이웃 '{}' 발견 -> queue에 추가\", neighbor);\n                }\n            }\n        }\n\n        // (4) BFS 종료 후, end 노드를 찾지 못했으면 실패 기록\n        if (!parent.containsKey(end)) {\n            log.warn(\"[BFS] '{}'에서 '{}'로 가는 경로를 찾지 못했습니다. (lineNum={})\", start, end, lineNum);\n            logFailedBfs(start, end, lineNum,\n                    \"BFS 종료 후 end 노드를 찾지 못함\",\n                    visited);\n            return Collections.emptyList();\n        }\n\n        // (5) 경로 역추적\n        List<String> path = new ArrayList<>();\n        String node = end;\n        while (node != null) {\n            path.add(node);\n            node = parent.get(node);\n        }\n        Collections.reverse(path);\n\n        log.info(\"[BFS] '{}' -> '{}' (lineNum={}) 경로: {}\", start, end, lineNum, path);\n        return path;\n    }\n\n    /**\n     * BFS 실패 시, JSON 파일(bfs_failures.json)에 기록하는 메서드.\n     * - \"start\", \"end\", \"lineNum\", \"reason\", \"visited\", \"timestamp\" 등을 함께 기록\n     */\n    private void logFailedBfs(String start,\n                              String end,\n                              String lineNum,\n                              String reason,\n                              Set<String> visited) {\n        // ObjectMapper에 Pretty Print(들여쓰기) 설정\n        ObjectMapper mapper = new ObjectMapper().enable(SerializationFeature.INDENT_OUTPUT);\n\n        List<Map<String, Object>> failedList = new ArrayList<>();\n        File file = new File(FAILED_BFS_FILE);\n\n        // 이미 파일이 있으면 기존 내용을 불러옴\n        if (file.exists()) {\n            try {\n                failedList = mapper.readValue(file, new TypeReference<>() {});\n            } catch (IOException e) {\n                log.error(\"Error reading {}: {}\", FAILED_BFS_FILE, e.getMessage());\n            }\n        }\n\n        // 새로운 실패 기록 생성\n        Map<String, Object> record = new HashMap<>();\n        record.put(\"start\", start);\n        record.put(\"end\", end);\n        record.put(\"lineNum\", lineNum);  // 호선 정보\n        record.put(\"timestamp\", LocalDateTime.now().toString());\n        record.put(\"reason\", reason);    // BFS 실패 사유\n        record.put(\"visited\", new ArrayList<>(visited));  // 방문했던 노드 목록\n        record.put(\"message\", \"BFS 경로를 찾지 못했습니다.\");\n\n        failedList.add(record);\n\n        // JSON 파일에 다시 기록\n        try {\n            mapper.writeValue(file, failedList);\n            log.info(\"BFS 실패 기록을 {} 파일에 저장했습니다.\", FAILED_BFS_FILE);\n        } catch (IOException e) {\n            log.error(\"Error writing to {}: {}\", FAILED_BFS_FILE, e.getMessage());\n        }\n    }\n\n}\n",
            "SubwaySyncService.java": "package com.example.subway.service;\n\nimport com.example.subway.domain.TrainInfo;\nimport com.example.subway.repository.TrainInfoRepository;\nimport com.fasterxml.jackson.core.type.TypeReference;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport com.fasterxml.jackson.databind.SerializationFeature;\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.scheduling.annotation.Scheduled;\nimport org.springframework.stereotype.Service;\nimport org.w3c.dom.*;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.URL;\nimport java.net.URLConnection;\nimport java.net.URLEncoder;\nimport java.nio.charset.StandardCharsets;\nimport java.time.LocalDateTime;\nimport java.util.*;\n\n@Slf4j\n@Service\npublic class SubwaySyncService {\n\n    private final TrainInfoRepository trainInfoRepository;\n    private final SubwayGraphService subwayGraphService;\n\n    // 최초 API 키\n    private String apiKey = \"755455636167793236306850475a51\";\n    // API URL 템플릿\n    private static final String SUBWAY_API_URL\n            = \"http://swopenAPI.seoul.go.kr/api/subway/%s/xml/realtimePosition/0/100/%s\";\n    // 로그 기록 파일명\n    private static final String LOG_FILE = \"log.json\";\n\n    public SubwaySyncService(TrainInfoRepository trainInfoRepository,\n                             SubwayGraphService subwayGraphService) {\n        this.trainInfoRepository = trainInfoRepository;\n        this.subwayGraphService  = subwayGraphService;\n    }\n\n    /**\n     * 지정된 주기로 각 호선의 열차정보를 동기화합니다.\n     */\n    @Scheduled(fixedDelayString = \"${myapp.schedule.subway-refresh}\")\n    public void syncTrains() {\n        Map<String, String> linesToSync = new LinkedHashMap<>();\n\n        for (int line = 1; line <= 9; line++) {\n            String lineKey = line + \"호선\";\n            linesToSync.put(lineKey, lineKey);\n        }\n        linesToSync.put(\"경강선\", \"경강선\");\n        linesToSync.put(\"경의중앙선\", \"경의선\");  // API는 \"경의중앙선\", DB에는 \"경의선\"으로 저장\n        linesToSync.put(\"경춘선\", \"경춘선\");\n        linesToSync.put(\"공항철도\", \"공항철도\");\n        linesToSync.put(\"서해선\", \"서해선\");\n        linesToSync.put(\"수인분당선\", \"수인분당선\");\n        linesToSync.put(\"신분당선\", \"신분당선\");\n        linesToSync.put(\"신림선\", \"신림선\");\n        linesToSync.put(\"우이신설선\", \"우이신설선\");\n\n        for (Map.Entry<String, String> entry : linesToSync.entrySet()) {\n            String apiLineName = entry.getKey();\n            String dbLineName  = entry.getValue();\n            try {\n                String lineNameEncoded = URLEncoder.encode(apiLineName, \"UTF-8\");\n                syncLine(lineNameEncoded, dbLineName);\n            } catch (Exception e) {\n                log.error(\"Failed to sync line {}: {}\", apiLineName, e.getMessage(), e);\n            }\n        }\n    }\n\n    /**\n     * 특정 호선(lineNameEncoded, lineNum)에 대한 열차정보 동기화 및 DB 정리 로직\n     */\n    private void syncLine(String lineNameEncoded, String lineNum) throws Exception {\n        // 인스턴스 변수 apiKey 사용\n        String apiUrl = String.format(SUBWAY_API_URL, apiKey, lineNameEncoded);\n        log.info(\"[SYNC] {}: API 호출 URL = {}\", lineNum, apiUrl);\n\n        URL url = new URL(apiUrl);\n        URLConnection connection = url.openConnection();\n        String contentType = connection.getContentType();\n        InputStream is = connection.getInputStream();\n\n        // JSON 형식 응답 처리\n        if (contentType != null && contentType.contains(\"application/json\")) {\n            String jsonResponse = new String(is.readAllBytes(), StandardCharsets.UTF_8);\n            ObjectMapper mapper = new ObjectMapper();\n            Map<String, Object> responseMap = mapper.readValue(jsonResponse, new TypeReference<Map<String, Object>>() {});\n            if (\"ERROR-337\".equals(responseMap.get(\"code\"))) {\n                // 현재 사용중인 API 키에 따라 순차적으로 교체\n                if (this.apiKey.equals(\"755455636167793236306850475a51\")) {\n                    this.apiKey = \"51434941476779323635637044786e\";\n                } else if (this.apiKey.equals(\"51434941476779323635637044786e\")) {\n                    this.apiKey = \"4f6b52794467793236325572567469\";\n                }\n                log.warn(\"[ERROR] {}: {} (API 키를 새 값으로 교체함)\", lineNum, jsonResponse);\n                return;\n            }\n            log.info(\"[INFO] {}: JSON 응답 수신: {}\", lineNum, jsonResponse);\n            return;\n        } else {\n            // XML 형식 응답 처리\n            Document doc = DocumentBuilderFactory.newInstance()\n                    .newDocumentBuilder().parse(is);\n            doc.getDocumentElement().normalize();\n\n            // <code> 태그를 통해 오류 코드 확인\n            NodeList codeNodes = doc.getElementsByTagName(\"code\");\n            if (codeNodes != null && codeNodes.getLength() > 0) {\n                String errorCode = codeNodes.item(0).getTextContent();\n                if (\"ERROR-337\".equals(errorCode)) {\n                    if (this.apiKey.equals(\"755455636167793236306850475a51\")) {\n                        this.apiKey = \"51434941476779323635637044786e\";\n                    } else if (this.apiKey.equals(\"51434941476779323635637044786e\")) {\n                        this.apiKey = \"4f6b52794467793236325572567469\";\n                    }\n                    log.warn(\"[ERROR] {}: 응답 오류 코드 {} 발견 (API 키를 새 값으로 교체함)\", lineNum, errorCode);\n                    return;\n                }\n            }\n\n            // 정상적인 XML 응답인 경우, 기존 로직대로 열차 정보를 처리합니다.\n            NodeList rowList = doc.getElementsByTagName(\"row\");\n            if (rowList.getLength() == 0) {\n                log.info(\"[INFO] {}: 열차 정보가 없습니다.\", lineNum);\n                return;\n            }\n\n            // 일반 노선용 그래프만 생성 (급행 여부와 무관하게 동일한 경로 탐색)\n            Map<String, List<String>> graph = subwayGraphService.buildGraph(lineNum, false);\n\n            // 이번 동기화에서 발견된 trainNo 추적\n            Set<String> fetchedTrainNos = new HashSet<>();\n\n            for (int i = 0; i < rowList.getLength(); i++) {\n                Node row = rowList.item(i);\n                if (row.getNodeType() != Node.ELEMENT_NODE) {\n                    continue;\n                }\n                Element element = (Element) row;\n\n                // API의 각 필드 값 추출\n                String subwayId      = getTagValue(element, \"subwayId\");\n                String statnId       = getTagValue(element, \"statnId\");\n                String trainNo       = getTagValue(element, \"trainNo\");\n                String lastRecptnDt  = getTagValue(element, \"lastRecptnDt\");\n                String recptnDt      = getTagValue(element, \"recptnDt\");\n                String upDown        = getTagValue(element, \"updnLine\");\n                String statnTid      = getTagValue(element, \"statnTid\");\n                String rawCurrStatn  = getTagValue(element, \"statnNm\");\n                String rawEndStatn   = getTagValue(element, \"statnTnm\");\n                String trainSttus    = getTagValue(element, \"trainSttus\");\n                String directAt      = getTagValue(element, \"directAt\");\n                String lstcarAt      = getTagValue(element, \"lstcarAt\");\n\n                // 현재역 및 종착역의 소괄호와 그 안의 내용 제거\n                String currStatn = removeParentheses(rawCurrStatn);\n                String endStatn  = removeParentheses(rawEndStatn);\n\n                if (trainNo == null || currStatn == null || endStatn == null) {\n                    log.warn(\"Skipping row due to null values: trainNo={}, currStatn={}, endStatn={}\",\n                            trainNo, currStatn, endStatn);\n                    continue;\n                }\n\n                fetchedTrainNos.add(trainNo);\n\n                Optional<TrainInfo> optTrain = trainInfoRepository.findByTrainNo(trainNo);\n                TrainInfo train;\n                if (optTrain.isEmpty()) {\n                    // --- [새 열차 추가] ---\n                    train = new TrainInfo();\n                    train.setSubwayId(subwayId);\n                    train.setStatnId(statnId);\n                    train.setTrainNo(trainNo);\n                    train.setLastRecptnDt(lastRecptnDt);\n                    train.setRecptnDt(recptnDt);\n                    train.setUpDown(upDown);\n                    train.setTrainSttus(trainSttus);\n                    train.setDirectAt(directAt);\n                    train.setLstcarAt(lstcarAt);\n                    train.setCurrentStation(currStatn);\n                    train.setStatnTid(statnTid);\n                    train.setEndStation(endStatn);\n                    train.setLineNum(lineNum);\n\n                    // BFS를 통해 현재역 ~ 종착역 경로 계산 (항상 일반 열차용 graph 사용)\n                    List<String> path = subwayGraphService.bfsPath(graph, currStatn, endStatn);\n                    log.debug(\"[NEW TRAIN] BFS path: {}\", path);\n\n                    train.setStationsJson(toJsonString(path));\n                    train.setUpdateTime(LocalDateTime.now());\n                    trainInfoRepository.save(train);\n\n                    log.info(\"[NEW TRAIN] {} - {} ( {} -> {} )\", trainNo, lineNum, currStatn, endStatn);\n                    // log.json에 신규 열차 추가 이벤트 기록\n                    logTrainEvent(\"NEW_TRAIN\", train);\n\n                } else {\n                    // --- [기존 열차 업데이트] ---\n                    train = optTrain.get();\n                    train.setSubwayId(subwayId);\n                    train.setStatnId(statnId);\n                    train.setTrainNo(trainNo);\n                    train.setLastRecptnDt(lastRecptnDt);\n                    train.setRecptnDt(recptnDt);\n                    train.setUpDown(upDown);\n                    train.setTrainSttus(trainSttus);\n                    train.setDirectAt(directAt);\n                    train.setLstcarAt(lstcarAt);\n                    train.setCurrentStation(currStatn);\n                    train.setStatnTid(statnTid);\n                    train.setEndStation(endStatn);\n                    train.setLineNum(lineNum);\n\n                    List<String> path = fromJsonString(train.getStationsJson());\n                    if (path != null && !path.isEmpty()) {\n                        int currIdx = path.indexOf(currStatn);\n                        if (currIdx > 0) {\n                            for (int idx = 0; idx < currIdx; idx++) {\n                                path.set(idx, null);\n                            }\n                            path.removeIf(Objects::isNull);\n                        }\n                        train.setStationsJson(toJsonString(path));\n                    }\n                    train.setUpdateTime(LocalDateTime.now());\n                    trainInfoRepository.save(train);\n\n                    log.info(\"[UPDATE TRAIN] {} - {} (현재역: {})\", trainNo, lineNum, currStatn);\n                    // log.json에 업데이트 이벤트 기록\n                    logTrainEvent(\"UPDATE_TRAIN\", train);\n                }\n            }\n\n\n// 삭제 이벤트 처리 (삭제되는 열차에 대해 log.json에도 기록)\n            List<TrainInfo> existingTrains = trainInfoRepository.findByLineNum(lineNum);\n            for (TrainInfo t : existingTrains) {\n                if (!fetchedTrainNos.contains(t.getTrainNo())) {\n                    trainInfoRepository.delete(t);\n                    log.info(\"[DELETE TRAIN] {} - {} (운행 종료)\", t.getTrainNo(), lineNum);\n                    // 삭제 이벤트도 log.json에 기록\n                    logTrainEvent(\"DELETE_TRAIN\", t);\n                }\n            }\n\n        }\n    }\n\n    private String getTagValue(Element element, String tag) {\n        NodeList list = element.getElementsByTagName(tag);\n        if (list.getLength() == 0) {\n            return null;\n        }\n        return list.item(0).getTextContent();\n    }\n\n    private String toJsonString(List<String> list) {\n        if (list == null) return \"[]\";\n        return \"[\" + String.join(\",\", list.stream().map(s -> \"\\\"\" + s + \"\\\"\").toList()) + \"]\";\n    }\n\n    private List<String> fromJsonString(String json) {\n        if (json == null || json.isBlank()) {\n            return new ArrayList<>();\n        }\n        String trimmed = json.trim();\n        if (trimmed.startsWith(\"[\") && trimmed.endsWith(\"]\")) {\n            trimmed = trimmed.substring(1, trimmed.length() - 1).trim();\n            if (trimmed.isEmpty()) {\n                return new ArrayList<>();\n            }\n            List<String> result = new ArrayList<>();\n            String[] tokens = trimmed.split(\",\");\n            for (String t : tokens) {\n                String val = t.trim().replaceAll(\"\\\"\", \"\");\n                result.add(val);\n            }\n            return result;\n        }\n        return new ArrayList<>();\n    }\n\n    private String removeParentheses(String input) {\n        if (input == null) {\n            return null;\n        }\n        return input.replaceAll(\"\\\\(.*?\\\\)\", \"\").trim();\n    }\n\n    /**\n     * 새로운 열차 추가 혹은 기존 열차 업데이트 이벤트를 log.json 파일에 기록합니다.\n     * 각 기록에는 timestamp, action, trainNo, lineNum, currentStation, endStation 등의 정보가 포함됩니다.\n     */\n    private void logTrainEvent(String action, TrainInfo train) {\n        ObjectMapper mapper = new ObjectMapper().enable(SerializationFeature.INDENT_OUTPUT);\n        List<Map<String, Object>> logList = new ArrayList<>();\n        File file = new File(LOG_FILE);\n\n        // 기존 log.json 파일이 존재하면 내용을 불러옵니다.\n        if (file.exists()) {\n            try {\n                logList = mapper.readValue(file, new TypeReference<List<Map<String, Object>>>() {});\n            } catch (IOException e) {\n                log.error(\"log.json 파일 읽기 실패: {}\", e.getMessage(), e);\n            }\n        }\n\n        // 새 로그 기록 생성\n        Map<String, Object> record = new HashMap<>();\n        record.put(\"timestamp\", LocalDateTime.now().toString());\n        record.put(\"action\", action);\n        record.put(\"trainNo\", train.getTrainNo());\n        record.put(\"lineNum\", train.getLineNum());\n        record.put(\"currentStation\", train.getCurrentStation());\n        record.put(\"endStation\", train.getEndStation());\n        record.put(\"upDown\", train.getUpDown());\n        record.put(\"express\", train.getDirectAt());\n        logList.add(record);\n\n        // log.json 파일에 기록 저장\n        try {\n            mapper.writeValue(file, logList);\n            log.info(\"log.json 파일에 {} 이벤트 기록 완료: {}\", action, record);\n        } catch (IOException e) {\n            log.error(\"log.json 파일 쓰기 실패: {}\", e.getMessage(), e);\n        }\n    }\n}\n"
        }
    }
}